<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      -->
<title>Demo: fMRI surface-based searchlights with LDA classifier</title>
<meta name="generator" content="MATLAB 24.1">
<link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
<meta name="DC.date" content="2025-09-21">
<meta name="DC.source" content="run_surface_searchlight.m">
<style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style>
</head>
<body>
<div class="content">
<h1>Demo: fMRI surface-based searchlights with LDA classifier</h1>
<!--introduction-->
<p>The data used here is available from <a href="http://cosmomvpa.org/datadb.zip">http://cosmomvpa.org/datadb.zip</a>
</p>
<p>This example uses the following dataset: + 'digit' A participant made finger pressed with the index and middle finger of the right hand during 4 runs in an fMRI study. Each run was divided in 4 blocks with presses of each finger and analyzed with the GLM, resulting in 2*4*4=32 t-values</p>
<p>A searchlight is run with a 100 voxel searchlight, using a disc for which the metric radius varies from node to node.</p>
<p>This example requires the surfing toolbox, github.com/nno/surfing</p>
<p>This example may take quite some time to run. For faster execution but lower spatial precision, set ld=16 below; for slower execution use ld=64.</p>
<p>If you use this code for a publication, please cite: Oosterhof, N.N., Wiestler, T, Downing, P.E., &amp; Diedrichsen, J. (2011) A comparison of volume-based and surface-based information mapping. Neuroimage. DOI:10.1016/j.neuroimage.2010.04.270</p>
<div>
<ol>
<li>For CoSMoMVPA's copyright information and license terms, #</li>
<li>see the COPYING file distributed with CoSMoMVPA. #</li>
</ol>
</div>
<!--/introduction-->
<h2>Contents</h2>
<div>
<ul>
<li>
<a href="#1">Check externals</a>
</li>
<li>
<a href="#2">Set data paths</a>
</li>
<li>
<a href="#4">Part 1: compute thickness of the cortex</a>
</li>
<li>
<a href="#6">For visualization purposes, read inflated surface</a>
</li>
<li>
<a href="#7">visualize surface in Matlab using AFNI Matlab toolbox</a>
</li>
<li>
<a href="#9">Part 2: run surface-based searchlight</a>
</li>
<li>
<a href="#10">set measure arguments</a>
</li>
<li>
<a href="#13">plot surface in Matlab using AFNI Matlab toolbox</a>
</li>
</ul>
</div>
<h2 id="1">Check externals</h2>
<pre class="codeinput">cosmo_check_external(<span class="string">'surfing'</span>);
cosmo_check_external(<span class="string">'afni'</span>);
</pre>
<h2 id="2">Set data paths</h2>
<p>The function cosmo_config() returns a struct containing paths to tutorial data. (Alternatively the paths can be set manually without using cosmo_config.)</p>
<pre class="codeinput">config = cosmo_config();

digit_study_path = fullfile(config.tutorial_data_path, <span class="string">'digit'</span>);
readme_fn = fullfile(digit_study_path, <span class="string">'README'</span>);
cosmo_type(readme_fn);

output_path = config.output_data_path;
</pre>
<pre class="codeoutput">Overview
--------
fMRI responses to a human participant pressing buttons with the index and middle finger.

Contents
--------
- glm_T_stats_allruns+orig.{BRIK,HEAD}: 
    t-statistics associated with finger presses. 
    There are 4 runs, each with 4 blocks. 
    Each block has two t-statistics, one for each of button presses for the 
index and middle finger (in that order). 
- epi+orig.{HEAD,BRIK}:
    A single EPI image.
- icoXX_mh.YY.asc:
    Surface anatomy meshes of two hemispheres with standard topology, generated 
    using AFNI SUMA's MapIcosahedron. Left and right hemisphere surfaces were
    merged in the order left, right; the first half of the nodes and faces refer 
    to the left hemisphere, the second half to the right hemisphere.
    XX={16,64} is the number of linear divisions of MapIcosahedron; surfaces
    have (XX^2)*10+2 nodes and XX^2*20 faces in each hemisphere.
    YY={pial_al,white_al} are the outer and inner surfaces around the grey matter
    generated by FreeSurfer. YY=intermediate_al is the node-wise average of the
    pial and white surfaces; this surface can be used for single-surface
    analyses when surfaces are generated using Caret or BrainVoyager
    YY=inflated_alCoMmedial are inflated surfaces with the center of mass
    along the medial side of the two hemispheres. These surfaces are suitable
    for visualization purposes.

Methods
-------
This dataset contains data from a fingerpress experiment where a participant 
(28y right-handed male) pressed buttons on a box with the index and middle 
finger of the right  hand while fMRI volumes were acquired. Over four runs, in 
total sixteen blocks of 72s finger presses were acquired; in each block the 
participant pressed the index and middle finger during different `mini-blocks' 
of 8 s each. Each block was preceded and followed by a 16s rest period. 
Functional data was preprocessed in AFNI with despiking, time slice correction, 
motion correction, and scaling to percent signal change by dividing the signal 
for each volume by the mean of the run. No spatial smoothing or interpolation 
was applied to the functional data, except for interpolation during motion 
correction. The preprocessed data was analyzed with a general linear model 
(GLM) with separate regressors for each finger and each block (and some 
regressors of no interest) to obtain t-values for each finger in each block. 

License
-------
The contents are made available by Nikolaas N. Oosterhof &lt;nikolaas.oosterhof 
|at| unitn.it&gt; under the Creative Commons CC0 1.0 Universal Public Domain 
Dedication ("CC0"). See the LICENSE file for details, or visit 
http://creativecommons.org/publicdomain/zero/1.0/deed.en.

Contact
-------
Nikolaas N. Oosterhof &lt;nikolaas.oosterhof |at| unitn.it&gt;


</pre>
<pre class="codeinput">
<span class="comment">% resolution parameter for input surfaces</span>
<span class="comment">% 64 is for high-quality results; use 16 for fast execution</span>
surface_ld = 16;

<span class="comment">% Define twin surface filenames (FreeSurfer)</span>
pial_fn = fullfile(digit_study_path, <span class="keyword">...</span>
                   sprintf(<span class="string">'ico%d_mh.pial_al.asc'</span>, surface_ld));
white_fn = fullfile(digit_study_path, <span class="keyword">...</span>
                    sprintf(<span class="string">'ico%d_mh.smoothwm_al.asc'</span>, surface_ld));

<span class="comment">% read the surface in pial_fn using surfing_read, and assign the vertices</span>
<span class="comment">% and faces to variables pial_v and pial_f, respectively</span>
<span class="comment">% &gt;@@&gt;</span>
[pial_v, pial_f] = surfing_read(pial_fn);
<span class="comment">% &lt;@@&lt;</span>

fprintf(<span class="string">'The pial surface has %d vertices, %d faces\n'</span>, <span class="keyword">...</span>
        size(pial_v, 1), size(pial_f, 1));

<span class="comment">% do the same for the white_fn, assign the faces and vertices to</span>
<span class="comment">% white_v and white_f</span>
<span class="comment">% &gt;@@&gt;</span>
[white_v, white_f] = surfing_read(white_fn);
<span class="comment">% &lt;@@&lt;</span>

fprintf(<span class="string">'The white surface has %d vertices, %d faces\n'</span>, <span class="keyword">...</span>
        size(pial_v, 1), size(pial_f, 1));

<span class="comment">% verify that the face information in pial_f and white_f are the same</span>
assert(isequal(white_f, pial_f));

<span class="comment">% show the content of the surfaces</span>
fprintf(<span class="string">'pial_v\n'</span>);
cosmo_disp(pial_v);

fprintf(<span class="string">'pial_f\n'</span>);
cosmo_disp(pial_f);

fprintf(<span class="string">'white_v\n'</span>);
cosmo_disp(white_v);

fprintf(<span class="string">'white_f\n'</span>);
cosmo_disp(white_f);
</pre>
<pre class="codeoutput">The pial surface has 5124 vertices, 10240 faces
The white surface has 5124 vertices, 10240 faces
pial_v
[ -32.3      19.8      41.4         
  -33.9      37.9       114         
  -27.9     -16.3       112         
    :         :          :          
   59.2       1.4      64.1         
   50.2     0.804      72.3         
   56.1      5.38      70.6 ]@5124x3
pial_f
[       43         1        13          
        58        43        13          
        43        58        44          
      :         :         :             
   4.9e+03  5.12e+03  4.55e+03          
   4.9e+03   4.9e+03  5.12e+03          
  4.55e+03  2.57e+03   4.9e+03 ]@10240x3
white_v
[ -36.4      23.6      38.6         
  -33.5      36.9       112         
  -27.5     -14.4       111         
    :         :          :          
   56.3      1.56      63.7         
   48.9      2.18      69.1         
   53.9      5.02      67.9 ]@5124x3
white_f
[       43         1        13          
        58        43        13          
        43        58        44          
      :         :         :             
   4.9e+03  5.12e+03  4.55e+03          
   4.9e+03   4.9e+03  5.12e+03          
  4.55e+03  2.57e+03   4.9e+03 ]@10240x3
</pre>
<h2 id="4">Part 1: compute thickness of the cortex</h2>
<pre class="codeinput">
<span class="comment">% compute the element-wise difference in coordinates between pial_v</span>
<span class="comment">% and white_v, and assign to a variable delta</span>
<span class="comment">% &gt;@@&gt;</span>
delta = pial_v - white_v;
<span class="comment">% &lt;@@&lt;</span>

<span class="comment">% square the differences element-wise, and assign to delta_squared.</span>
<span class="comment">% hint: use ".^2"</span>
<span class="comment">% &gt;@@&gt;</span>
delta_squared = delta.^2;
<span class="comment">% &lt;@@&lt;</span>

<span class="comment">% compute the thickness squared, by summing the elements in</span>
<span class="comment">% delta_squared along the second dimension. Assign to thickness_squared</span>
<span class="comment">% &gt;@@&gt;</span>
thickness_squared = sum(delta_squared, 2);
<span class="comment">% &lt;@@&lt;</span>

<span class="comment">% finally compute the thickness by taking the square root, assign</span>
<span class="comment">% the result to thickness</span>
<span class="comment">% &gt;@@&gt;</span>
thickness = sqrt(thickness_squared);
<span class="comment">% &lt;@@&lt;</span>
</pre>
<p>plot a histogram of the thickness values &gt;@@&gt;</p>
<pre class="codeinput">hist(thickness, 100);
xlabel(<span class="string">'thickness (mm)'</span>);
<span class="comment">% &lt;@@&lt;</span>
</pre>
<img vspace="5" hspace="5" src="run_surface_searchlight_01.png" alt=""> <h2 id="6">For visualization purposes, read inflated surface</h2>
<pre class="codeinput">inflated_fn = fullfile(digit_study_path, <span class="keyword">...</span>
                       sprintf(<span class="string">'ico%d_mh.inflated_alCoMmedial.asc'</span>, surface_ld));
[infl_v, infl_f] = surfing_read(inflated_fn);
fprintf(<span class="string">'The inflated surface has %d vertices, %d faces\n'</span>, <span class="keyword">...</span>
        size(infl_v, 1), size(infl_f, 1));
</pre>
<pre class="codeoutput">The inflated surface has 5124 vertices, 10240 faces
</pre>
<h2 id="7">visualize surface in Matlab using AFNI Matlab toolbox</h2>
<pre class="codeinput">nvertices = size(infl_v, 1);

min_thickness = 1;
max_thickness = 4;
show_edge = false;

opt = struct();
opt.ShowEdge = show_edge;
opt.Zlim = [min_thickness, max_thickness]; <span class="comment">% this does not seem to work</span>
opt.Dim = <span class="string">'3D'</span>;

<span class="keyword">if</span> show_edge
    t = <span class="string">'with edges'</span>;
<span class="keyword">else</span>
    t = <span class="string">'without edges'</span>;
<span class="keyword">end</span>

desc = <span class="string">'thickness'</span>;
header = strrep([desc <span class="string">' '</span> t], <span class="string">'_'</span>, <span class="string">' '</span>);

range_adj_thickness = max(min_thickness, <span class="keyword">...</span>
                          min(thickness, max_thickness));

DispIVSurf(infl_v, infl_f, 1:nvertices, <span class="keyword">...</span>
           range_adj_thickness, 0, opt);
title(sprintf(<span class="string">'Inflated %s'</span>, header));
</pre>
<pre class="codeoutput">DispIVSurf verbose: z-buffer mode.
DispIVSurf verbose: Scaling ITvect to fit colormap
DispIVSurf verbose: Set hold to off
DispIVSurf verbose: Drawing Patches
DispIVSurf verbose: Applied interp for Shade.
DispIVSurf verbose: Set Edgecolor to none
DispIVSurf verbose: Set view to 3D
DispIVSurf verbose: Displaying colormap
DispIVSurf verbose: Setting Axes properties
DispIVSurf verbose: Done
</pre>
<img vspace="5" hspace="5" src="run_surface_searchlight_02.png" alt=""> <pre class="codeinput">ds_thickness = struct();
ds_thickness.fa.node_indices = 1:nvertices;
ds_thickness.samples = thickness(:)';
ds_thickness.a.fdim.labels = {<span class="string">'node_indices'</span>};
ds_thickness.a.fdim.values = {(1:nvertices)'};

<span class="comment">% July 2019: strangely enough these gifti files cannot be read by AFNI SUMA.</span>
<span class="comment">% https://github.com/CoSMoMVPA/CoSMoMVPA/issues/186</span>
<span class="keyword">if</span> cosmo_check_external(<span class="string">'gifti'</span>, false)
    output_fn = fullfile(config.output_data_path, <span class="string">'thickness.gii'</span>);
    cosmo_map2surface(ds_thickness, output_fn, <span class="string">'encoding'</span>, <span class="string">'ASCII'</span>);
<span class="keyword">end</span>

<span class="comment">% AFNI output</span>
output_fn = fullfile(config.output_data_path, <span class="string">'thickness.niml.dset'</span>);
cosmo_map2surface(ds_thickness, output_fn);
</pre>
<h2 id="9">Part 2: run surface-based searchlight</h2>
<pre class="codeinput">
<span class="comment">% Load volumetric functional data</span>
data_path = digit_study_path;
data_fn = fullfile(data_path, <span class="string">'glm_T_stats_perblock+orig'</span>);

<span class="comment">% set targets</span>
targets = repmat(1:2, 1, 16)';    <span class="comment">% class labels: 1 2 1 2 1 2 1 2 1 2 ... 1 2</span>
chunks = floor(((1:32) - 1) / 8) + 1; <span class="comment">% run labels:   1 1 1 1 1 1 1 1 2 2 ... 4 4</span>

<span class="comment">% load functional data</span>
ds = cosmo_fmri_dataset(data_fn, <span class="string">'targets'</span>, targets, <span class="string">'chunks'</span>, chunks);

<span class="comment">% remove zero elements</span>
zero_msk = all(ds.samples == 0, 1);
ds = cosmo_slice(ds, ~zero_msk, 2);

fprintf(<span class="string">'Dataset has %d samples and %d features\n'</span>, size(ds.samples));

<span class="comment">% print dataset</span>
fprintf(<span class="string">'Dataset input:\n'</span>);
cosmo_disp(ds);
</pre>
<pre class="codeoutput">Dataset has 32 samples and 168097 features
Dataset input:
.sa                                                                       
  .labels                                                                 
    { 'fi_i_R1_B01#0_Tstat'                                               
      'fi_m_R1_B01#0_Tstat'                                               
      'fi_i_R1_B02#0_Tstat'                                               
               :                                                          
      'fi_m_R4_B03#0_Tstat'                                               
      'fi_i_R4_B04#0_Tstat'                                               
      'fi_m_R4_B04#0_Tstat' }@32x1                                        
  .stats                                                                  
    { 'Ttest(168)'                                                        
      'Ttest(168)'                                                        
      'Ttest(168)'                                                        
           :                                                              
      'Ttest(168)'                                                        
      'Ttest(168)'                                                        
      'Ttest(168)' }@32x1                                                 
  .targets                                                                
    [ 1                                                                   
      2                                                                   
      1                                                                   
      :                                                                   
      2                                                                   
      1                                                                   
      2 ]@32x1                                                            
  .chunks                                                                 
    [ 1                                                                   
      1                                                                   
      1                                                                   
      :                                                                   
      4                                                                   
      4                                                                   
      4 ]@32x1                                                            
.a                                                                        
  .vol                                                                    
    .mat                                                                  
      [ -2.5         0         0      71.2                                
           0      -2.5         0       112                                
           0         0       2.5        43                                
           0         0         0         1 ]                              
    .dim                                                                  
      [ 61        84        41 ]                                          
    .xform                                                                
      'scanner_anat'                                                      
  .fdim                                                                   
    .labels                                                               
      { 'i'                                                               
        'j'                                                               
        'k' }                                                             
    .values                                                               
      { [ 1         2         3  ...  59        60        61 ]@1x61       
        [ 1         2         3  ...  82        83        84 ]@1x84       
        [ 1         2         3  ...  39        40        41 ]@1x41 }     
.samples                                                                  
  [     0         0         0  ...  -0.878     0.178      4.66            
        0         0         0  ...    2.48      -0.3      1.12            
        0         0         0  ...   -1.05    -0.707      1.04            
      :         :         :            :         :         :              
    -2.21    -0.243    -0.377  ...   -1.59         1     0.987            
    -1.97      1.06     0.673  ...   -1.23      1.41     0.999            
     -4.5      1.16      1.53  ...    1.86     -1.31     0.405 ]@32x168097
.fa                                                                       
  .i                                                                      
    [ 1         2         3  ...  59        60        61 ]@1x168097       
  .j                                                                      
    [ 1         1         1  ...  84        84        84 ]@1x168097       
  .k                                                                      
    [ 3         3         3  ...  36        36        36 ]@1x168097       
</pre>
<h2 id="10">set measure arguments</h2>
<p>Assign to measure a function handle to cosmo_cross_validation_measure &gt;@@&gt;</p>
<pre class="codeinput">measure = @cosmo_crossvalidation_measure;
<span class="comment">% &lt;@@&lt;</span>

<span class="comment">% use as arguments for the measure:</span>
<span class="comment">% - classifier: cosmo_classify_naive_bayes</span>
<span class="comment">% - partitions: odd-even partitions</span>
<span class="comment">% assign these to a struct measure_args</span>
<span class="comment">% &gt;@@&gt;</span>
measure_args = struct();
measure_args.classifier = @cosmo_classify_naive_bayes;
measure_args.partitions = cosmo_oddeven_partitioner(ds);
<span class="comment">% &lt;@@&lt;</span>
</pre>
<p>Set neighborhood parameters Make a cell with the outer surface vertices (pial_v), the inner surface vertices (white_v), and the face indices (pial_f or white_f). Assign to a variable surface_def &gt;@@&gt;</p>
<pre class="codeinput">surface_def = {pial_v, white_v, pial_f};
<span class="comment">% &lt;@@&lt;</span>

<span class="comment">% Define a surface-based neighborhood (using cosmo_surficial_neighborhood)</span>
<span class="comment">% with approximately 100 voxels per searchlight. Assign the result</span>
<span class="comment">% to nbrhood.</span>
<span class="comment">% Note: if you have issues compiling the fast marching toolbox,</span>
<span class="comment">% you could alternatively (with little loss of precision / change in</span>
<span class="comment">% results) add as additional arguments: 'metric','dijkstra'</span>

<span class="comment">% &gt;@@&gt;</span>
nbrhood = cosmo_surficial_neighborhood(ds, surface_def, <span class="keyword">...</span>
                                       <span class="string">'count'</span>, 100, <span class="keyword">...</span>
                                       <span class="string">'metric'</span>, <span class="string">'dijkstra'</span>);
<span class="comment">% &lt;@@&lt;</span>

<span class="comment">% visualize the neighborhood using cosmo_disp.</span>
<span class="comment">% What is the feature attribute of the neighborhood?</span>
</pre>
<pre class="codeoutput">Warning: found 911 / 5124 center nodes outside the volume, these will be
ignored. 
Using 168097 / 210084 voxels in functional volume mask
+00:00:04 [####################] -00:00:00  r=22.97, 100.0 vox
</pre>
<p>run surface-based searchlight using the variables define above Assign the result to ds_sl &gt;@@&gt;</p>
<pre class="codeinput">ds_sl = cosmo_searchlight(ds, nbrhood, measure, measure_args);
<span class="comment">% &lt;@@&lt;</span>
</pre>
<pre class="codeoutput">+00:00:01 [####################] -00:00:00  
</pre>
<h2 id="13">plot surface in Matlab using AFNI Matlab toolbox</h2>
<pre class="codeinput">nvertices = size(infl_v, 1);
show_edge = false;

opt = struct();
opt.ShowEdge = show_edge;
opt.Dim = <span class="string">'3D'</span>;

<span class="keyword">if</span> show_edge
    t = <span class="string">'with edges'</span>;
<span class="keyword">else</span>
    t = <span class="string">'without edges'</span>;
<span class="keyword">end</span>

desc = <span class="string">'classification accuracy'</span>;
header = strrep([desc <span class="string">' '</span> t], <span class="string">'_'</span>, <span class="string">' '</span>);

DispIVSurf(infl_v, infl_f, 1:nvertices, <span class="keyword">...</span>
           ds_sl.samples', 0, opt);
title(sprintf(<span class="string">'Inflated %s'</span>, header));

<span class="comment">% July 2019: strangely enough these gifti files cannot be read by AFNI SUMA.</span>
<span class="comment">% https://github.com/CoSMoMVPA/CoSMoMVPA/issues/186</span>
<span class="keyword">if</span> cosmo_check_external(<span class="string">'gifti'</span>, false)
    output_fn = fullfile(config.output_data_path, <span class="string">'digit_accuracy.gii'</span>);
    cosmo_map2surface(ds_sl, output_fn, <span class="string">'encoding'</span>, <span class="string">'ASCII'</span>);
<span class="keyword">end</span>

<span class="comment">% AFNI output</span>
output_fn = fullfile(config.output_data_path, <span class="string">'digit_accuracy.niml.dset'</span>);
cosmo_map2surface(ds_sl, output_fn);

<span class="comment">% Show citation information</span>
cosmo_check_external(<span class="string">'-cite'</span>);
</pre>
<pre class="codeoutput">DispIVSurf verbose: z-buffer mode.
DispIVSurf verbose: Scaling ITvect to fit colormap
DispIVSurf verbose: Set hold to off
DispIVSurf verbose: Drawing Patches
DispIVSurf verbose: Applied interp for Shade.
DispIVSurf verbose: Set Edgecolor to none
DispIVSurf verbose: Set view to 3D
DispIVSurf verbose: Displaying colormap
DispIVSurf verbose: Setting Axes properties
DispIVSurf verbose: Done
If you use CoSMoMVPA and/or some other toolboxes for a publication, please cite:

Z. Saad, G. Chen. AFNI Matlab library. available online from https://github.com/afni/AFNI

N. N. Oosterhof, T. Wiestler, J. Diedrichsen (2011). A comparison of volume-based and surface-based multi-voxel pattern analysis. Neuroimage 56 (2), 593-600. Surfing toolbox available online from http://github.com/nno/surfing

N. N. Oosterhof, A. C. Connolly, J. V. Haxby (2016). CoSMoMVPA: multi-modal multivariate pattern analysis of neuroimaging data in Matlab / GNU Octave. Frontiers in Neuroinformatics, doi:10.3389/fninf.2016.00027.. CoSMoMVPA toolbox available online from http://cosmomvpa.org

The Mathworks, Natick, MA, United States. Matlab 24.1.0.2537033 (R2024a) (February 21, 2024). available online from http://www.mathworks.com

</pre>
<img vspace="5" hspace="5" src="run_surface_searchlight_03.png" alt=""> <p class="footer">
<br>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2024a</a>
<br>
</p>
</div>
<!--
##### SOURCE BEGIN #####
%% Demo: fMRI surface-based searchlights with LDA classifier
%
% The data used here is available from http://cosmomvpa.org/datadb.zip
%
% This example uses the following dataset:
% + 'digit'
%    A participant made finger pressed with the index and middle finger of
%    the right hand during 4 runs in an fMRI study. Each run was divided in
%    4 blocks with presses of each finger and analyzed with the GLM,
%    resulting in 2*4*4=32 t-values
%
% A searchlight is run with a 100 voxel searchlight, using a
% disc for which the metric radius varies from node to node.
%
% This example requires the surfing toolbox, github.com/nno/surfing
%
% This example may take quite some time to run. For faster execution but
% lower spatial precision, set ld=16 below; for slower execution use ld=64.
%
% If you use this code for a publication, please cite:
% Oosterhof, N.N., Wiestler, T, Downing, P.E., & Diedrichsen, J. (2011)
% A comparison of volume-based and surface-based information mapping.
% Neuroimage. DOI:10.1016/j.neuroimage.2010.04.270
%
% #   For CoSMoMVPA's copyright information and license terms,   #
% #   see the COPYING file distributed with CoSMoMVPA.           #

%% Check externals
cosmo_check_external('surfing');
cosmo_check_external('afni');

%% Set data paths
% The function cosmo_config() returns a struct containing paths to tutorial
% data. (Alternatively the paths can be set manually without using
% cosmo_config.)
config = cosmo_config();

digit_study_path = fullfile(config.tutorial_data_path, 'digit');
readme_fn = fullfile(digit_study_path, 'README');
cosmo_type(readme_fn);

output_path = config.output_data_path;

%%

% resolution parameter for input surfaces
% 64 is for high-quality results; use 16 for fast execution
surface_ld = 16;

% Define twin surface filenames (FreeSurfer)
pial_fn = fullfile(digit_study_path, ...
                   sprintf('ico%d_mh.pial_al.asc', surface_ld));
white_fn = fullfile(digit_study_path, ...
                    sprintf('ico%d_mh.smoothwm_al.asc', surface_ld));

% read the surface in pial_fn using surfing_read, and assign the vertices
% and faces to variables pial_v and pial_f, respectively
% >@@>
[pial_v, pial_f] = surfing_read(pial_fn);
% <@@<

fprintf('The pial surface has %d vertices, %d faces\n', ...
        size(pial_v, 1), size(pial_f, 1));

% do the same for the white_fn, assign the faces and vertices to
% white_v and white_f
% >@@>
[white_v, white_f] = surfing_read(white_fn);
% <@@<

fprintf('The white surface has %d vertices, %d faces\n', ...
        size(pial_v, 1), size(pial_f, 1));

% verify that the face information in pial_f and white_f are the same
assert(isequal(white_f, pial_f));

% show the content of the surfaces
fprintf('pial_v\n');
cosmo_disp(pial_v);

fprintf('pial_f\n');
cosmo_disp(pial_f);

fprintf('white_v\n');
cosmo_disp(white_v);

fprintf('white_f\n');
cosmo_disp(white_f);

%% Part 1: compute thickness of the cortex

% compute the element-wise difference in coordinates between pial_v
% and white_v, and assign to a variable delta
% >@@>
delta = pial_v - white_v;
% <@@<

% square the differences element-wise, and assign to delta_squared.
% hint: use ".^2"
% >@@>
delta_squared = delta.^2;
% <@@<

% compute the thickness squared, by summing the elements in
% delta_squared along the second dimension. Assign to thickness_squared
% >@@>
thickness_squared = sum(delta_squared, 2);
% <@@<

% finally compute the thickness by taking the square root, assign
% the result to thickness
% >@@>
thickness = sqrt(thickness_squared);
% <@@<
%%
% plot a histogram of the thickness values
% >@@>
hist(thickness, 100);
xlabel('thickness (mm)');
% <@@<

%% For visualization purposes, read inflated surface
inflated_fn = fullfile(digit_study_path, ...
                       sprintf('ico%d_mh.inflated_alCoMmedial.asc', surface_ld));
[infl_v, infl_f] = surfing_read(inflated_fn);
fprintf('The inflated surface has %d vertices, %d faces\n', ...
        size(infl_v, 1), size(infl_f, 1));

%% visualize surface in Matlab using AFNI Matlab toolbox
nvertices = size(infl_v, 1);

min_thickness = 1;
max_thickness = 4;
show_edge = false;

opt = struct();
opt.ShowEdge = show_edge;
opt.Zlim = [min_thickness, max_thickness]; % this does not seem to work
opt.Dim = '3D';

if show_edge
    t = 'with edges';
else
    t = 'without edges';
end

desc = 'thickness';
header = strrep([desc ' ' t], '_', ' ');

range_adj_thickness = max(min_thickness, ...
                          min(thickness, max_thickness));

DispIVSurf(infl_v, infl_f, 1:nvertices, ...
           range_adj_thickness, 0, opt);
title(sprintf('Inflated %s', header));

%%
ds_thickness = struct();
ds_thickness.fa.node_indices = 1:nvertices;
ds_thickness.samples = thickness(:)';
ds_thickness.a.fdim.labels = {'node_indices'};
ds_thickness.a.fdim.values = {(1:nvertices)'};

% July 2019: strangely enough these gifti files cannot be read by AFNI SUMA.
% https://github.com/CoSMoMVPA/CoSMoMVPA/issues/186
if cosmo_check_external('gifti', false)
    output_fn = fullfile(config.output_data_path, 'thickness.gii');
    cosmo_map2surface(ds_thickness, output_fn, 'encoding', 'ASCII');
end

% AFNI output
output_fn = fullfile(config.output_data_path, 'thickness.niml.dset');
cosmo_map2surface(ds_thickness, output_fn);

%% Part 2: run surface-based searchlight

% Load volumetric functional data
data_path = digit_study_path;
data_fn = fullfile(data_path, 'glm_T_stats_perblock+orig');

% set targets
targets = repmat(1:2, 1, 16)';    % class labels: 1 2 1 2 1 2 1 2 1 2 ... 1 2
chunks = floor(((1:32) - 1) / 8) + 1; % run labels:   1 1 1 1 1 1 1 1 2 2 ... 4 4

% load functional data
ds = cosmo_fmri_dataset(data_fn, 'targets', targets, 'chunks', chunks);

% remove zero elements
zero_msk = all(ds.samples == 0, 1);
ds = cosmo_slice(ds, ~zero_msk, 2);

fprintf('Dataset has %d samples and %d features\n', size(ds.samples));

% print dataset
fprintf('Dataset input:\n');
cosmo_disp(ds);

%% set measure arguments
% Assign to measure a function handle to cosmo_cross_validation_measure
% >@@>
measure = @cosmo_crossvalidation_measure;
% <@@<

% use as arguments for the measure:
% - classifier: cosmo_classify_naive_bayes
% - partitions: odd-even partitions
% assign these to a struct measure_args
% >@@>
measure_args = struct();
measure_args.classifier = @cosmo_classify_naive_bayes;
measure_args.partitions = cosmo_oddeven_partitioner(ds);
% <@@<

%%
% Set neighborhood parameters
% Make a cell with the outer surface vertices (pial_v),
% the inner surface vertices (white_v), and the face
% indices (pial_f or white_f). Assign to a variable surface_def
% >@@>
surface_def = {pial_v, white_v, pial_f};
% <@@<

% Define a surface-based neighborhood (using cosmo_surficial_neighborhood)
% with approximately 100 voxels per searchlight. Assign the result
% to nbrhood.
% Note: if you have issues compiling the fast marching toolbox,
% you could alternatively (with little loss of precision / change in
% results) add as additional arguments: 'metric','dijkstra'

% >@@>
nbrhood = cosmo_surficial_neighborhood(ds, surface_def, ...
                                       'count', 100, ...
                                       'metric', 'dijkstra');
% <@@<

% visualize the neighborhood using cosmo_disp.
% What is the feature attribute of the neighborhood?

%%
% run surface-based searchlight using the variables define above
% Assign the result to ds_sl
% >@@>
ds_sl = cosmo_searchlight(ds, nbrhood, measure, measure_args);
% <@@<

%% plot surface in Matlab using AFNI Matlab toolbox

nvertices = size(infl_v, 1);
show_edge = false;

opt = struct();
opt.ShowEdge = show_edge;
opt.Dim = '3D';

if show_edge
    t = 'with edges';
else
    t = 'without edges';
end

desc = 'classification accuracy';
header = strrep([desc ' ' t], '_', ' ');

DispIVSurf(infl_v, infl_f, 1:nvertices, ...
           ds_sl.samples', 0, opt);
title(sprintf('Inflated %s', header));

% July 2019: strangely enough these gifti files cannot be read by AFNI SUMA.
% https://github.com/CoSMoMVPA/CoSMoMVPA/issues/186
if cosmo_check_external('gifti', false)
    output_fn = fullfile(config.output_data_path, 'digit_accuracy.gii');
    cosmo_map2surface(ds_sl, output_fn, 'encoding', 'ASCII');
end

% AFNI output
output_fn = fullfile(config.output_data_path, 'digit_accuracy.niml.dset');
cosmo_map2surface(ds_sl, output_fn);

% Show citation information
cosmo_check_external('-cite');

##### SOURCE END #####
-->
</body>
</html>
