<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      -->
<title>MEEG time-frequency searchlight</title>
<meta name="generator" content="MATLAB 24.1">
<link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
<meta name="DC.date" content="2025-09-21">
<meta name="DC.source" content="run_meeg_timefreq_measures.m">
<style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style>
</head>
<body>
<div class="content">
<h1>MEEG time-frequency searchlight</h1>
<!--introduction-->
<p>This example shows MVPA analyses performed on MEEG data, using a searchlight across the time, frequency and channel dimensions</p>
<p>The input dataset involved a paradigm with electrical median nerve stimulation for durations of 2s at 20Hz.</p>
<p>The code presented here can be adapted for other MEEG analyses, but there are a few potential caveats: * assignment of targets (labels of conditions) is based here on stimulation periods versus pre-stimulation periods. In typical analyses the targets should be based on different trial conditions, for example as set a FieldTrip .trialinfo field. * assignment of chunks (parts of the data that are assumed to be independent) is based on a trial-by-trial basis. For cross-validation, the number of chunks is reduced to two to speed up the analysis. * the time window used for analyses is rather small. This means that in particular for time-freq analysis a lot of data is missing, especially for early and late timepoints in the lower frequency bands. For typical analyses it may be preferred to use a wider time window. * the current examples do not perform baseline corrections or signal normalizations, which may reduce discriminatory power.</p>
<p>Note: running this code requires FieldTrip.</p>
<div>
<ol>
<li>For CoSMoMVPA's copyright information and license terms, #</li>
<li>see the COPYING file distributed with CoSMoMVPA. #</li>
</ol>
</div>
<!--/introduction-->
<h2>Contents</h2>
<div>
<ul>
<li>
<a href="#1">get timelock data in CoSMoMVPA format</a>
</li>
<li>
<a href="#2">run searchlight</a>
</li>
<li>
<a href="#3">visualize results</a>
</li>
</ul>
</div>
<h2 id="1">get timelock data in CoSMoMVPA format</h2>
<pre class="codeinput">
<span class="comment">% set configuration</span>
config = cosmo_config();
data_path = fullfile(config.tutorial_data_path, <span class="string">'meg_20hz'</span>);

<span class="comment">% show dataset information</span>
readme_fn = fullfile(data_path, <span class="string">'README'</span>);
cosmo_type(readme_fn);

<span class="comment">% reset citation list</span>
cosmo_check_external(<span class="string">'-tic'</span>);

<span class="comment">% load data</span>
data_fn = fullfile(data_path, <span class="string">'subj102_B01_20Hz_timefreq.mat'</span>);
data_tf = load(data_fn);

<span class="comment">% convert to cosmomvpa struct</span>
ds = cosmo_meeg_dataset(data_tf);

<span class="comment">% set the target (trial condition)</span>
<span class="comment">% here, 1=pre-stimulus, 2=peri-stimulus</span>
ds.sa.targets = ds.sa.trialinfo(:, 1);

<span class="comment">% set the chunks (independent measurements)</span>
<span class="comment">% in this dataset, the first half of the samples (in order)</span>
<span class="comment">% are the post-trials;</span>
<span class="comment">% the second half the pre-trials</span>
ds.sa.chunks = [(1:145) (1:145)]';

<span class="comment">% just to check everything is ok</span>
cosmo_check_dataset(ds);

<span class="comment">% get rid of features with at least one NaN value across samples</span>
fa_nan_mask = sum(isnan(ds.samples), 1) &gt; 0;
fprintf(<span class="string">'%d / %d features have NaN\n'</span>, <span class="keyword">...</span>
        sum(fa_nan_mask), numel(fa_nan_mask));
ds = cosmo_slice(ds, ~fa_nan_mask, 2);

<span class="comment">% Define a channel neighborhood uses meg_combined_from_planar, which means</span>
<span class="comment">% that input are planar channels but the output has</span>
<span class="comment">% combined-planar channels. Note that with EEG data there is no need to set</span>
<span class="comment">% the chan_type, as there is only a single type.</span>
chan_type = <span class="string">'meg_combined_from_planar'</span>;
chan_count = 10;        <span class="comment">% use 10 channel locations (relative to the combined</span>
<span class="comment">% planar channels)</span>
<span class="comment">% as we use meg_combined_from_planar there are</span>
<span class="comment">% 20 channels in each searchlight because</span>
<span class="comment">% gradiometers are paired</span>

<span class="comment">% Use cosmo_meeg_chan_neighborhood to define a channel neighborhood,</span>
<span class="comment">% with 'count' set to chan_count, and 'chantype' set to chan_type.</span>
<span class="comment">% Assign the result to chan_nbrhood. How many searchlight centers are in</span>
<span class="comment">% the neighborhood?</span>
<span class="comment">% &gt;@@&gt;</span>
chan_nbrhood = cosmo_meeg_chan_neighborhood(ds, <span class="string">'count'</span>, chan_count, <span class="keyword">...</span>
                                            <span class="string">'chantype'</span>, chan_type);
fprintf(<span class="string">'There are %d channel neighborhood centers\n'</span>, <span class="keyword">...</span>
        numel(chan_nbrhood.neighbors));
<span class="comment">% &lt;@@&lt;</span>

<span class="comment">% Define the frequency neighborhood using 9 time bins</span>
freq_radius = 0; <span class="comment">% 4*2+1=9 freq bins</span>

<span class="comment">% &gt;@@&gt;</span>
<span class="comment">% Use cosmo_interval_neighborhood to define the frequency neighborhood.</span>
<span class="comment">% Assign the result to a variable 'freq_nbrhood'</span>
<span class="comment">% How many searchlight centers are in the neighborhood?</span>
freq_nbrhood = cosmo_interval_neighborhood(ds, <span class="string">'freq'</span>, <span class="keyword">...</span>
                                           <span class="string">'radius'</span>, freq_radius);
fprintf(<span class="string">'There are %d frequency neighborhood centers\n'</span>, <span class="keyword">...</span>
        numel(freq_nbrhood.neighbors));
<span class="comment">% &lt;@@&lt;</span>

<span class="comment">% Define the temporal neighborhood using 5 time bins</span>

time_radius = 2; <span class="comment">% 2*2+1=5 time bines</span>
<span class="comment">% Use cosmo_interval_neighborhood to define the temporal neighborhood.</span>
<span class="comment">% Assign the result to a variable 'time_nbrhood'</span>
<span class="comment">% How many searchlight centers are in the neighborhood?</span>
<span class="comment">% &gt;@@&gt;</span>
time_nbrhood = cosmo_interval_neighborhood(ds, <span class="string">'time'</span>, <span class="keyword">...</span>
                                           <span class="string">'radius'</span>, time_radius);
fprintf(<span class="string">'There are %d temporal neighborhood centers\n'</span>, <span class="keyword">...</span>
        numel(time_nbrhood.neighbors));

<span class="comment">% &lt;@@&lt;</span>

<span class="comment">% cross the three neighborhoods to get a chan-freq-time neighborhood,</span>
<span class="comment">% using cosmo_cross_neighborhood</span>
<span class="comment">% How many searchlight centers are in the crossed neighborhood?</span>

<span class="comment">% &gt;@@&gt;</span>
nbrhood = cosmo_cross_neighborhood(ds, {chan_nbrhood, <span class="keyword">...</span>
                                        freq_nbrhood, <span class="keyword">...</span>
                                        time_nbrhood});
<span class="comment">% &lt;@@&lt;</span>

<span class="comment">% Count how many features there are, on average, in each neighborhood,</span>
<span class="comment">% and store the results in a variable 'nbrhood_nfeatures'. Then print its</span>
<span class="comment">% average and standard deviation</span>

<span class="comment">% &gt;@@&gt;</span>
nbrhood_nfeatures = cellfun(@numel, nbrhood.neighbors);
fprintf(<span class="string">'Features have on average %.1f +/- %.1f neighbors\n'</span>, <span class="keyword">...</span>
        mean(nbrhood_nfeatures), std(nbrhood_nfeatures));
<span class="comment">% &lt;@@&lt;</span>

<span class="comment">% divide .sa.chunks in ds into four chunks using cosmo_chunkize</span>

<span class="comment">% &gt;@@&gt;</span>
nfolds = 4;
ds.sa.chunks = cosmo_chunkize(ds, nfolds);
<span class="comment">% &lt;@@&lt;</span>

<span class="comment">% Define partitions using cosmo_nfold_partitioner, and use</span>
<span class="comment">% cosmo_balance_partitions afterwards. Assign the result to a variable</span>
<span class="comment">% 'partitions'</span>
<span class="comment">% &gt;@@&gt;</span>
partitions = cosmo_nfold_partitioner(ds);
partitions = cosmo_balance_partitions(partitions, ds);
<span class="comment">% &lt;@@&lt;</span>

<span class="comment">% Set the measure arguments</span>
measure_args = struct();
measure_args.partitions = partitions;
</pre>
<pre class="codeoutput">Summary
-------
MEG data in raw, time-locked and time-frequency formats.

Contents
--------
- subj102_B01_20Hz.fif            raw MEG recording
- preproc.m                       Matlab preprocessing script (based on 
                                  FieldTrip)
- subj102_B01_20Hz_timefreq.mat   Time-locked data (generated by preproc.m)
- subj102_B01_20Hz_timelock.mat   Time-frequency data  (generated by preproc.m)
- LICENSE                         License file 
- README                          This file

Methods
-------
The dataset involved a paradigm with electrical median nerve stimulation with a 
human participant for durations of 2s at 20Hz. Data was acquired at 1khz using 
a neuromag306 system. 
Trial info in the .mat files: 1=pre-stimulus, 2=peri/post-stimulus

License
-------
The contents are made available by Nathan Weisz &lt;nathanweisz |at| me.com&gt; and 
Gianpaolo Demarchi &lt;gianpaolo.demarchi |at| unitn.it&gt; under the Creative 
Commons CC0 1.0 Universal Public Domain Dedication ("CC0"). See the LICENSE 
file for details, or visit 
http://creativecommons.org/publicdomain/zero/1.0/deed.en.

Acknowledgements
----------------
Thanks to Nathan Weisz and Gianpaolo Demarchi for providing this dataset, and 
an anonymous participant for volunteering during the recordings.

Contact
-------
Nikolaas N. Oosterhof &lt;nikolaas.oosterhof |at| unitn.it&gt;
16968 / 92718 features have NaN
There are 102 channel neighborhood centers
There are 18 frequency neighborhood centers
There are 17 temporal neighborhood centers
+00:00:00 [####################] -00:00:00  crossing neighborhoods
Features have on average 77.2 +/- 32.1 neighbors
</pre>
<h2 id="2">run searchlight</h2>
<pre class="codeinput">
<span class="comment">% only keep features with at least 10 neighbors</span>
<span class="comment">% (some have zero neighbors - in particular, those with low frequencies</span>
<span class="comment">% early or late in time)</span>
center_ids = find(nbrhood_nfeatures &gt; 10);

<span class="comment">% instead of using the cosmo_searchlight function, use the faster</span>
<span class="comment">% cosmo_naive_bayes_classifier_searchlight.</span>
<span class="comment">% As input it takes a dataset, neighborhood, and measure_args.</span>
<span class="comment">% Also provide it with the 'center_ids',center_ids argument as well</span>
<span class="comment">% to avoid computing results for features without neighbors.</span>

<span class="comment">% It may take a while before results for the first fold are computed</span>
result_ds = cosmo_naive_bayes_classifier_searchlight(ds, <span class="keyword">...</span>
                                                     nbrhood, measure_args, <span class="keyword">...</span>
                                                     <span class="string">'center_ids'</span>, center_ids);
</pre>
<pre class="codeoutput">+00:00:04 [####################] -00:00:00  
</pre>
<h2 id="3">visualize results</h2>
<pre class="codeinput">
<span class="comment">% deduce layout from output</span>
layout = cosmo_meeg_find_layout(result_ds);
fprintf(<span class="string">'The output uses layout %s\n'</span>, layout.name);

<span class="comment">% map to FT struct for visualization</span>
tf_map = cosmo_map2meeg(result_ds);

<span class="comment">% show figure</span>
figure();
cfg = [];
<span class="keyword">if</span> cosmo_wtf(<span class="string">'is_octave'</span>)
    <span class="comment">% GNU Octave does not show data when labels are shown</span>
    cfg.interactive = <span class="string">'no'</span>;
    cfg.showlabels = <span class="string">'no'</span>;
<span class="keyword">else</span>
    <span class="comment">% Matlab supports interactive viewing and labels</span>
    cfg.interactive = <span class="string">'yes'</span>;
    cfg.showlabels = <span class="string">'yes'</span>;
<span class="keyword">end</span>
cfg.zlim = [0 1];
cfg.layout       = layout;
ft_multiplotTFR(cfg, tf_map);

<span class="comment">% Show citation information</span>
cosmo_check_external(<span class="string">'-cite'</span>);
</pre>
<pre class="codeoutput">The output uses layout neuromag306cmb.lay
the call to "ft_selectdata" took 0 seconds and required the additional allocation of an estimated NaN MB
the call to "ft_prepare_layout" took 0 seconds and required the additional allocation of an estimated NaN MB
the call to "ft_multiplotTFR" took 0 seconds and required the additional allocation of an estimated NaN MB
If you use CoSMoMVPA and/or some other toolboxes for a publication, please cite:

R. Oostenveld, P. Fries, E. Maris, J.-M. Schoffelen (2011). FieldTrip: Open Source Software for Advanced Analysis of MEG, EEG, and Invasive Electrophysiological Data, Computational Intelligence and Neuroscience, vol. 2011, Article ID 156869, 9 pages.doi:10.1155/2011/156869. FieldTrip toolbox available online from http://fieldtrip.fcdonders.nl

N. N. Oosterhof, A. C. Connolly, J. V. Haxby (2016). CoSMoMVPA: multi-modal multivariate pattern analysis of neuroimaging data in Matlab / GNU Octave. Frontiers in Neuroinformatics, doi:10.3389/fninf.2016.00027.. CoSMoMVPA toolbox available online from http://cosmomvpa.org

The Mathworks, Natick, MA, United States. Matlab 24.1.0.2537033 (R2024a) (February 21, 2024). available online from http://www.mathworks.com

</pre>
<img vspace="5" hspace="5" src="run_meeg_timefreq_measures_01.png" alt=""> <p class="footer">
<br>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2024a</a>
<br>
</p>
</div>
<!--
##### SOURCE BEGIN #####
%% MEEG time-frequency searchlight
%
% This example shows MVPA analyses performed on MEEG data, using a
% searchlight across the time, frequency and channel dimensions
%
% The input dataset involved a paradigm with electrical median nerve
% stimulation for durations of 2s at 20Hz.
%
% The code presented here can be adapted for other MEEG analyses, but
% there are a few potential caveats:
% * assignment of targets (labels of conditions) is based here on
%   stimulation periods versus pre-stimulation periods. In typical
%   analyses the targets should be based on different trial conditions, for
%   example as set a FieldTrip .trialinfo field.
% * assignment of chunks (parts of the data that are assumed to be
%   independent) is based on a trial-by-trial basis. For cross-validation,
%   the number of chunks is reduced to two to speed up the analysis.
% * the time window used for analyses is rather small. This means that in
%   particular for time-freq analysis a lot of data is missing, especially
%   for early and late timepoints in the lower frequency bands. For typical
%   analyses it may be preferred to use a wider time window.
% * the current examples do not perform baseline corrections or signal
%   normalizations, which may reduce discriminatory power.
%
% Note: running this code requires FieldTrip.
%
% #   For CoSMoMVPA's copyright information and license terms,   #
% #   see the COPYING file distributed with CoSMoMVPA.           #

%% get timelock data in CoSMoMVPA format

% set configuration
config = cosmo_config();
data_path = fullfile(config.tutorial_data_path, 'meg_20hz');

% show dataset information
readme_fn = fullfile(data_path, 'README');
cosmo_type(readme_fn);

% reset citation list
cosmo_check_external('-tic');

% load data
data_fn = fullfile(data_path, 'subj102_B01_20Hz_timefreq.mat');
data_tf = load(data_fn);

% convert to cosmomvpa struct
ds = cosmo_meeg_dataset(data_tf);

% set the target (trial condition)
% here, 1=pre-stimulus, 2=peri-stimulus
ds.sa.targets = ds.sa.trialinfo(:, 1);

% set the chunks (independent measurements)
% in this dataset, the first half of the samples (in order)
% are the post-trials;
% the second half the pre-trials
ds.sa.chunks = [(1:145) (1:145)]';

% just to check everything is ok
cosmo_check_dataset(ds);

% get rid of features with at least one NaN value across samples
fa_nan_mask = sum(isnan(ds.samples), 1) > 0;
fprintf('%d / %d features have NaN\n', ...
        sum(fa_nan_mask), numel(fa_nan_mask));
ds = cosmo_slice(ds, ~fa_nan_mask, 2);

% Define a channel neighborhood uses meg_combined_from_planar, which means
% that input are planar channels but the output has
% combined-planar channels. Note that with EEG data there is no need to set
% the chan_type, as there is only a single type.
chan_type = 'meg_combined_from_planar';
chan_count = 10;        % use 10 channel locations (relative to the combined
% planar channels)
% as we use meg_combined_from_planar there are
% 20 channels in each searchlight because
% gradiometers are paired

% Use cosmo_meeg_chan_neighborhood to define a channel neighborhood,
% with 'count' set to chan_count, and 'chantype' set to chan_type.
% Assign the result to chan_nbrhood. How many searchlight centers are in
% the neighborhood?
% >@@>
chan_nbrhood = cosmo_meeg_chan_neighborhood(ds, 'count', chan_count, ...
                                            'chantype', chan_type);
fprintf('There are %d channel neighborhood centers\n', ...
        numel(chan_nbrhood.neighbors));
% <@@<

% Define the frequency neighborhood using 9 time bins
freq_radius = 0; % 4*2+1=9 freq bins

% >@@>
% Use cosmo_interval_neighborhood to define the frequency neighborhood.
% Assign the result to a variable 'freq_nbrhood'
% How many searchlight centers are in the neighborhood?
freq_nbrhood = cosmo_interval_neighborhood(ds, 'freq', ...
                                           'radius', freq_radius);
fprintf('There are %d frequency neighborhood centers\n', ...
        numel(freq_nbrhood.neighbors));
% <@@<

% Define the temporal neighborhood using 5 time bins

time_radius = 2; % 2*2+1=5 time bines
% Use cosmo_interval_neighborhood to define the temporal neighborhood.
% Assign the result to a variable 'time_nbrhood'
% How many searchlight centers are in the neighborhood?
% >@@>
time_nbrhood = cosmo_interval_neighborhood(ds, 'time', ...
                                           'radius', time_radius);
fprintf('There are %d temporal neighborhood centers\n', ...
        numel(time_nbrhood.neighbors));

% <@@<

% cross the three neighborhoods to get a chan-freq-time neighborhood,
% using cosmo_cross_neighborhood
% How many searchlight centers are in the crossed neighborhood?

% >@@>
nbrhood = cosmo_cross_neighborhood(ds, {chan_nbrhood, ...
                                        freq_nbrhood, ...
                                        time_nbrhood});
% <@@<

% Count how many features there are, on average, in each neighborhood,
% and store the results in a variable 'nbrhood_nfeatures'. Then print its
% average and standard deviation

% >@@>
nbrhood_nfeatures = cellfun(@numel, nbrhood.neighbors);
fprintf('Features have on average %.1f +/- %.1f neighbors\n', ...
        mean(nbrhood_nfeatures), std(nbrhood_nfeatures));
% <@@<

% divide .sa.chunks in ds into four chunks using cosmo_chunkize

% >@@>
nfolds = 4;
ds.sa.chunks = cosmo_chunkize(ds, nfolds);
% <@@<

% Define partitions using cosmo_nfold_partitioner, and use
% cosmo_balance_partitions afterwards. Assign the result to a variable
% 'partitions'
% >@@>
partitions = cosmo_nfold_partitioner(ds);
partitions = cosmo_balance_partitions(partitions, ds);
% <@@<

% Set the measure arguments
measure_args = struct();
measure_args.partitions = partitions;

%% run searchlight

% only keep features with at least 10 neighbors
% (some have zero neighbors - in particular, those with low frequencies
% early or late in time)
center_ids = find(nbrhood_nfeatures > 10);

% instead of using the cosmo_searchlight function, use the faster
% cosmo_naive_bayes_classifier_searchlight.
% As input it takes a dataset, neighborhood, and measure_args.
% Also provide it with the 'center_ids',center_ids argument as well
% to avoid computing results for features without neighbors.

% It may take a while before results for the first fold are computed
result_ds = cosmo_naive_bayes_classifier_searchlight(ds, ...
                                                     nbrhood, measure_args, ...
                                                     'center_ids', center_ids);
%% visualize results

% deduce layout from output
layout = cosmo_meeg_find_layout(result_ds);
fprintf('The output uses layout %s\n', layout.name);

% map to FT struct for visualization
tf_map = cosmo_map2meeg(result_ds);

% show figure
figure();
cfg = [];
if cosmo_wtf('is_octave')
    % GNU Octave does not show data when labels are shown
    cfg.interactive = 'no';
    cfg.showlabels = 'no';
else
    % Matlab supports interactive viewing and labels
    cfg.interactive = 'yes';
    cfg.showlabels = 'yes';
end
cfg.zlim = [0 1];
cfg.layout       = layout;
ft_multiplotTFR(cfg, tf_map);

% Show citation information
cosmo_check_external('-cite');

##### SOURCE END #####
-->
</body>
</html>
