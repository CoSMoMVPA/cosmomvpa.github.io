    <!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Frequently Asked/Anticipated Questions &#8212; CoSMo Multivariate Pattern Analysis toolbox 1.0rc1 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=83e35b93" />
    <link rel="stylesheet" type="text/css" href="_static/nature.css?v=279e0f84" />
    <script src="_static/documentation_options.js?v=b2dc1058"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="copyright" title="Copyright" href="copyright.html" />
    <link rel="next" title="Contact information" href="contact.html" />
    <link rel="prev" title="demo surface tfce" href="matlab/demo_surface_tfce.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="contact.html" title="Contact information"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="matlab/demo_surface_tfce.html" title="demo surface tfce"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">CoSMoMVPA</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="documentation.html" accesskey="U">Documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Frequently Asked/Anticipated Questions</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="frequently-asked-anticipated-questions">
<span id="faq"></span><h1><a class="toc-backref" href="#id7" role="doc-backlink">Frequently Asked/Anticipated Questions</a><a class="headerlink" href="#frequently-asked-anticipated-questions" title="Link to this heading">¶</a></h1>
<nav class="contents" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#frequently-asked-anticipated-questions" id="id7">Frequently Asked/Anticipated Questions</a></p>
<ul>
<li><p><a class="reference internal" href="#general" id="id8">General</a></p>
<ul>
<li><p><a class="reference internal" href="#how-should-i-cite-cosmomvpa" id="id9">How should I cite CoSMoMVPA?</a></p></li>
<li><p><a class="reference internal" href="#what-is-the-history-of-cosmomvpa" id="id10">What is the history of CoSMoMVPA?</a></p></li>
<li><p><a class="reference internal" href="#what-are-the-main-features" id="id11">What are the main features?</a></p></li>
<li><p><a class="reference internal" href="#what-does-cosmomvpa-not-provide" id="id12">What does CoSMoMVPA <em>not</em> provide?</a></p></li>
<li><p><a class="reference internal" href="#does-it-integrate-with-pymvpa" id="id13">Does it integrate with PyMVPA?</a></p></li>
<li><p><a class="reference internal" href="#does-it-run-on-gnu-octave" id="id14">Does it run on GNU Octave?</a></p></li>
<li><p><a class="reference internal" href="#how-fast-does-it-run" id="id15">How fast does it run?</a></p></li>
<li><p><a class="reference internal" href="#what-should-i-use-as-input-for-mvpa" id="id16">What should I use as input for MVPA?</a></p></li>
<li><p><a class="reference internal" href="#who-are-the-developers-of-cosmomvpa" id="id17">Who are the developers of CoSMoMVPA?</a></p></li>
<li><p><a class="reference internal" href="#which-classifiers-are-available" id="id18">Which classifiers are available?</a></p></li>
<li><p><a class="reference internal" href="#which-platforms-does-it-support" id="id19">Which platforms does it support?</a></p></li>
<li><p><a class="reference internal" href="#what-future-features-can-be-expected" id="id20">What future features can be expected?</a></p></li>
<li><p><a class="reference internal" href="#how-can-i-contact-the-developers-directly" id="id21">How can I contact the developers directly?</a></p></li>
<li><p><a class="reference internal" href="#is-there-a-mailinglist" id="id22">Is there a mailinglist?</a></p></li>
<li><p><a class="reference internal" href="#why-do-you-encourage-balanced-partitions" id="id23">Why do you encourage balanced partitions?</a></p></li>
<li><p><a class="reference internal" href="#does-the-lda-linear-discriminant-analysis-classifier-use-shrinkage-normalization" id="id24">Does the LDA (linear discriminant analysis) classifier use shrinkage / normalization?</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#how-do-i" id="id25">How do I …</a></p>
<ul>
<li><p><a class="reference internal" href="#find-the-correspondence-between-voxel-indices-in-afni-and-feature-indices-in-cosmomvpa" id="id26">Find the correspondence between voxel indices in AFNI and feature indices in CoSMoMVPA</a></p></li>
<li><p><a class="reference internal" href="#get-ecog-data-in-a-cosmomvpa-struct" id="id27">Get ECoG data in a CoSMoMVPA struct</a></p></li>
<li><p><a class="reference internal" href="#get-temporal-data-in-a-cosmomvpa-struct" id="id28">Get temporal data in a CoSMoMVPA struct</a></p></li>
<li><p><a class="reference internal" href="#run-group-analysis" id="id29">Run group analysis</a></p></li>
<li><p><a class="reference internal" href="#make-an-intersection-mask-across-participants" id="id30">Make an intersection mask across participants</a></p></li>
<li><p><a class="reference internal" href="#compute-for-a-group-of-participants-who-were-scanned-with-mri-the-overlap-of-their-masks" id="id31">Compute for a group of participants who were scanned with MRI the overlap of their masks</a></p></li>
<li><p><a class="reference internal" href="#run-group-analysis-on-time-by-time-generalization-measures" id="id32">Run group analysis on time-by-time generalization measures</a></p></li>
<li><p><a class="reference internal" href="#use-libsvm" id="id33">Use LIBSVM</a></p></li>
<li><p><a class="reference internal" href="#use-surface-based-mapping-with-a-low-resolution-output-surface" id="id34">Use surface-based mapping with a low-resolution output surface</a></p></li>
<li><p><a class="reference internal" href="#correct-for-multiple-comparisons" id="id35">Correct for multiple comparisons</a></p></li>
<li><p><a class="reference internal" href="#do-cross-modal-decoding-across-three-modalities" id="id36">Do cross-modal decoding across three modalities</a></p></li>
<li><p><a class="reference internal" href="#compute-classification-accuracies-manually" id="id37">Compute classification accuracies manually</a></p></li>
<li><p><a class="reference internal" href="#make-a-merged-hemisphere-from-a-left-and-right-hemisphere" id="id38">Make a merged hemisphere from a left and right hemisphere</a></p></li>
<li><p><a class="reference internal" href="#merge-surface-data-from-two-hemispheres" id="id39">Merge surface data from two hemispheres</a></p></li>
<li><p><a class="reference internal" href="#visualize-and-store-multiple-fmri-volumes" id="id40">Visualize and store multiple fMRI volumes</a></p></li>
<li><p><a class="reference internal" href="#average-along-features-in-a-neighborhood" id="id41">Average along features in a neighborhood</a></p></li>
<li><p><a class="reference internal" href="#select-a-time-interval-in-an-meeg-dataset" id="id42">Select a time interval in an MEEG dataset</a></p></li>
<li><p><a class="reference internal" href="#select-a-particular-channel-type-in-an-meeg-dataset" id="id43">Select a particular channel type in an MEEG dataset</a></p></li>
<li><p><a class="reference internal" href="#use-only-a-subset-of-channels-for-my-analysis" id="id44">Use only a subset of channels for my analysis?</a></p></li>
<li><p><a class="reference internal" href="#should-i-fisher-transform-correlation-values" id="id45">Should I Fisher-transform correlation values?</a></p></li>
<li><p><a class="reference internal" href="#average-samples-in-a-deterministic-manner" id="id46">Average samples in a deterministic manner?</a></p></li>
<li><p><a class="reference internal" href="#select-only-a-subset-of-features-in-a-neighborhood" id="id47">Select only a subset of features in a neighborhood?</a></p></li>
<li><p><a class="reference internal" href="#use-multiple-comparison-correction-for-a-time-course" id="id48">Use multiple-comparison correction for a time course?</a></p></li>
<li><p><a class="reference internal" href="#classify-different-groups-of-participants-such-as-patients-versus-controls" id="id49">Classify different groups of participants (such as patients versus controls)?</a></p></li>
<li><p><a class="reference internal" href="#when-running-an-meeg-searchlight-have-the-same-channels-in-the-output-dataset-as-in-the-input-dataset" id="id50">When running an MEEG searchlight, have the same channels in the output dataset as in the input dataset?</a></p></li>
<li><p><a class="reference internal" href="#save-meeg-data-when-i-get-the-error-value-for-fdim-channel-label-is-not-supported" id="id51">Save MEEG data when I get the error “value for fdim channel label is not supported”?</a></p></li>
<li><p><a class="reference internal" href="#run-a-2-x-2-within-subject-anova" id="id52">Run a 2 x 2 within-subject ANOVA?</a></p></li>
<li><p><a class="reference internal" href="#use-a-fieldtrip-source-dataset-that-uses-a-fake-channel-structure" id="id53">Use a FieldTrip source dataset that uses a ‘fake’ channel structure</a></p></li>
<li><p><a class="reference internal" href="#run-cosmo-montecarlo-cluster-stat-on-a-cluster-with-multiple-nodes" id="id54">Run <cite>cosmo_montecarlo_cluster_stat</cite> on a cluster with multiple nodes</a></p></li>
<li><p><a class="reference internal" href="#why-should-i-consider-re-meaning-when-doing-representational-similarity-analysis-rsa" id="id55">Why should I consider re-meaning when doing representational similarity analysis (RSA)?</a></p></li>
<li><p><a class="reference internal" href="#import-brainstorm-data" id="id56">Import BrainStorm data</a></p></li>
<li><p><a class="reference internal" href="#compute-the-correlation-between-two-dissimilarity-matrices" id="id57">Compute the correlation between two dissimilarity matrices</a></p></li>
<li><p><a class="reference internal" href="#use-the-generalization-measure-with-different-durations-for-training-and-test-set" id="id58">Use the generalization measure with different durations for training and test set?</a></p></li>
<li><p><a class="reference internal" href="#get-the-classifier-weights-after-training-a-classifier" id="id59">Get the classifier weights after training a classifier?</a></p></li>
<li><p><a class="reference internal" href="#get-coordinates-of-voxels-in-a-cosmomvpa-fmri-dataset" id="id60">Get coordinates of voxels in a CoSMoMVPA fMRI dataset?</a></p></li>
<li><p><a class="reference internal" href="#compute-representational-similarity-across-chunks" id="id61">Compute representational similarity across chunks?</a></p></li>
<li><p><a class="reference internal" href="#run-group-analysis-on-time-generalization-results" id="id62">Run group analysis on time generalization results?</a></p></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
<section id="general">
<h2><a class="toc-backref" href="#id8" role="doc-backlink">General</a><a class="headerlink" href="#general" title="Link to this heading">¶</a></h2>
<section id="how-should-i-cite-cosmomvpa">
<span id="how-to-cite"></span><h3><a class="toc-backref" href="#id9" role="doc-backlink">How should I cite CoSMoMVPA?</a><a class="headerlink" href="#how-should-i-cite-cosmomvpa" title="Link to this heading">¶</a></h3>
<p>Please cite <span id="id1">[<a class="reference internal" href="references.html#id24" title="Oosterhof, N. N., Connolly, A. C., and Haxby, J. V. CoSMoMVPA: multi-modal multivariate pattern analysis of neuroimaging data in Matlab / GNU Octave. Frontiers in Neuroinformatics, 2016. doi:10.3389/fninf.2016.00027.">OCH16</a>]</span>:</p>
<blockquote>
<div><p>Oosterhof, N. N., Connolly, A. C., and Haxby, J. V. (2016). CoSMoMVPA: multi-modal multivariate pattern analysis of neuroimaging data in Matlab / GNU Octave. Frontiers in Neuroinformatics, <a class="extlink-doi reference external" href="http://dx.doi.org/10.3389/fninf.2016.00027">doi: 10.3389/fninf.2016.00027</a>.</p>
</div></blockquote>
<p>BiBTeX record:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@article</span><span class="p">{</span><span class="n">OCH16</span><span class="p">,</span>
<span class="n">author</span> <span class="o">=</span> <span class="p">{</span><span class="n">Oosterhof</span><span class="p">,</span> <span class="n">Nikolaas</span> <span class="n">N</span> <span class="ow">and</span> <span class="n">Connolly</span><span class="p">,</span> <span class="n">Andrew</span> <span class="n">C</span> <span class="ow">and</span> <span class="n">Haxby</span><span class="p">,</span> <span class="n">James</span> <span class="n">V</span><span class="p">},</span>
<span class="n">title</span> <span class="o">=</span> <span class="p">{{</span><span class="n">CoSMoMVPA</span><span class="p">:</span> <span class="n">multi</span><span class="o">-</span><span class="n">modal</span> <span class="n">multivariate</span> <span class="n">pattern</span> <span class="n">analysis</span> <span class="n">of</span> <span class="n">neuroimaging</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">Matlab</span> <span class="o">/</span> <span class="n">GNU</span> <span class="n">Octave</span><span class="p">}},</span>
<span class="n">journal</span> <span class="o">=</span> <span class="p">{</span><span class="n">Frontiers</span> <span class="ow">in</span> <span class="n">Neuroinformatics</span><span class="p">},</span>
<span class="n">doi</span> <span class="o">=</span> <span class="p">{</span><span class="mf">10.3389</span><span class="o">/</span><span class="n">fninf</span><span class="mf">.2016.00027</span><span class="p">},</span>
<span class="n">year</span> <span class="o">=</span> <span class="p">{</span><span class="mi">2016</span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="what-is-the-history-of-cosmomvpa">
<h3><a class="toc-backref" href="#id10" role="doc-backlink">What is the history of CoSMoMVPA?</a><a class="headerlink" href="#what-is-the-history-of-cosmomvpa" title="Link to this heading">¶</a></h3>
<blockquote>
<div><p>CoSMoMVPA was started when Gunnar Blohm and Sara Fabri invited the developers (ACC and NNO) to speak at the <em>2013 Summer School in Computational Sensory-Motor Neuroscience</em> ( <a class="reference external" href="http://www.compneurosci.com/CoSMo2013/">CoSMo 2013 workshop</a> ) about multivariate pattern analysis methods.</p>
<p>In a few days they wrote the basic functionality including the dataset structure (inspired by <a class="reference external" href="http://pymvpa.org">PyMVPA</a>), basic input/output support for the NIFTI format, correlation analysis, several classifiers, cross-validation, and representational similarity analysis. They also decided to use restructured text to build a website, and wrote a custom build script to generate documentation for the website, including multiple versions of Matlab files to generate both exercises files (with some code to be filled in) and solution files (with all the code).</p>
<p>Their plan was to let participants write a basic MVPA toolbox in two days (see the <a class="reference internal" href="cosmo2013.html#cosmo2013"><span class="std std-ref">exercises</span></a>). This was, with hindsight, a tad ambitious.</p>
<p>The initial components in <a class="reference external" href="http://cosmomvpa.org">CoSMoMVPA</a> still stand, but quite a few things have changed in the meantime. CoSMoMVPA has added support for various file formats, including surface-based data and MEEG data. It also supports a wider range of analyses. Finally, there is a new set of <a class="reference internal" href="rhul2016.html#rhul2016"><span class="std std-ref">exercises</span></a>, less aimed at writing your own toolbox, but more at understanding and implementing basic MVPA techniques using <a class="reference external" href="http://cosmomvpa.org">CoSMoMVPA</a>.</p>
<p>For recent changes, see the <a class="reference internal" href="changelog.html#changelog"><span class="std std-ref">Changelog</span></a>.</p>
</div></blockquote>
</section>
<section id="what-are-the-main-features">
<h3><a class="toc-backref" href="#id11" role="doc-backlink">What are the main features?</a><a class="headerlink" href="#what-are-the-main-features" title="Link to this heading">¶</a></h3>
<p><a class="reference external" href="http://cosmomvpa.org">CoSMoMVPA</a> provides:</p>
<blockquote>
<div><ul>
<li><p>A simple, yet powerful, <a class="reference internal" href="cosmomvpa_concepts.html#cosmomvpa-dataset"><span class="std std-ref">data structure</span></a> that treats fMRI and MEEG data both as first-class citizens.</p></li>
<li><p><em>Simple</em>, <em>light-weight</em>, and <em>modular</em> functions.</p></li>
<li><p>Implementations of <em>all common MVPA analyses</em> through <a class="reference internal" href="cosmomvpa_concepts.html#cosmomvpa-measure"><span class="std std-ref">measures</span></a>, such as:</p>
<blockquote>
<div><ul class="simple">
<li><p>correlation split-half</p></li>
<li><p>representational similarity</p></li>
<li><p>crossvalidation with classifiers</p></li>
<li><p>generalization over time</p></li>
</ul>
</div></blockquote>
</li>
<li><p><a class="reference internal" href="cosmomvpa_concepts.html#cosmomvpa-neighborhood"><span class="std std-ref">Neighborhoods</span></a> in various spaces, including</p>
<blockquote>
<div><ul>
<li><p>volumetric and surface-based (fMRI)</p></li>
<li><p>time, frequency, sensors, and source elements (MEEG)</p></li>
<li><p>all combinations of the above, for example:</p>
<blockquote>
<div><ul class="simple">
<li><p>voxel x time (volumetric fMRI)</p></li>
<li><p>node x time (surface-based fMRI)</p></li>
<li><p>time x sensor (MEEG)</p></li>
<li><p>time x frequency x sensor (MEEG)</p></li>
<li><p>time x source element (MEEG)</p></li>
<li><p>time x frequency x source element (MEEG)</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
<p>where each of the above <a class="reference internal" href="cosmomvpa_concepts.html#cosmomvpa-measure"><span class="std std-ref">measures</span></a> can be used with a neighborhood to run searchlights in all the above spaces.</p>
</li>
<li><p>Support for a wide variety of image formats, including:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference external" href="http://afni.nimh.nih.gov">AFNI</a></p></li>
<li><p><a class="reference external" href="http://www.fil.ion.ucl.ac.uk/spm/">SPM</a></p></li>
<li><p><a class="reference external" href="http://www.nitrc.org/projects/nifti">NIFTI</a></p></li>
<li><p><a class="reference external" href="http://imaging.mrc-cbu.cam.ac.uk/imaging/FormatSpmAnalyze">ANALYZE</a></p></li>
<li><p><a class="reference external" href="http://www.brainvoyager.com">BrainVoyager</a></p></li>
<li><p><a class="reference external" href="http://fieldtrip.fcdonders.nl">FieldTrip</a></p></li>
<li><p><a class="reference external" href="http://sccn.ucsd.edu/eeglab">EEGLAB</a> (ASCII)</p></li>
</ul>
</div></blockquote>
</li>
<li><p>proper Monte Carlo cluster-based <a class="reference internal" href="matlab/cosmo_montecarlo_cluster_stat.html#cosmo-montecarlo-cluster-stat"><span class="std std-ref">multiple comparison correction</span></a> (<a class="reference internal" href="matlab/demo_surface_tfce.html#demo-surface-tfce"><span class="std std-ref">example</span></a>), using either Threshold-Free Cluster Enhancement or traditional cluster-size based Monte Carlo simulations, in all the supported neighborhood spaces..</p></li>
<li><p>support for both the <a class="reference external" href="http://www.mathworks.com/products/matlab/">Matlab</a> and GNU <a class="reference external" href="https://www.gnu.org/software/octave/">Octave</a> platforms.</p></li>
<li><p>various runnable <a class="reference internal" href="contents_demo.html#contents-demo-rst"><span class="std std-ref">example scripts</span></a> and <a class="reference internal" href="rhul2016.html#rhul2016"><span class="std std-ref">exerices</span></a>, describing both on how to perform certain types of analyses (i.e., from a user perspective), and on how typical MVP analyses can be implemented (from a programmer perspective).</p></li>
</ul>
</div></blockquote>
</section>
<section id="what-does-cosmomvpa-not-provide">
<h3><a class="toc-backref" href="#id12" role="doc-backlink">What does CoSMoMVPA <em>not</em> provide?</a><a class="headerlink" href="#what-does-cosmomvpa-not-provide" title="Link to this heading">¶</a></h3>
<blockquote>
<div><p>It does not provide (and probably never will):</p>
<ul class="simple">
<li><p>Preprocessing of data. It assumed that the data has been preprocessed using other packages (such as AFNI, SPM, or FieldTrip for fMRI; EEGLAB or FieldTrip for MEEG). For fMRI analyses, in most use-case scenarios, it may be preferable to use response estimates from a General Linear Model.</p></li>
<li><p>Implementations of complicated analyses (such as hyperalignment, nested cross validation, recursive feature elimination). If you want to do these, consider using <a class="reference external" href="http://pymvpa.org">PyMVPA</a>.</p></li>
<li><p>A Graphical User Interface (GUI). First, it’s a lot of work to build such a thing. Second, writing the code to perform the analyses could be considered as more instructive: it requires one to actually <em>think</em> about the analysis, rather than just clicking on buttons.</p></li>
<li><p>Pretty visualization of fMRI data. Although there is basic functionality for showing slices of fMRI data (through <code class="docutils literal notranslate"><span class="pre">cosmo_plot_slices</span></code>, for better visualization we suggest to use either your preferred fMRI analysis package, or <a class="reference external" href="http://www.nitrc.org/projects/mricron">MRIcron</a>.</p></li>
</ul>
<p>Also, it does not make coffee for you.</p>
</div></blockquote>
</section>
<section id="does-it-integrate-with-pymvpa">
<h3><a class="toc-backref" href="#id13" role="doc-backlink">Does it integrate with PyMVPA?</a><a class="headerlink" href="#does-it-integrate-with-pymvpa" title="Link to this heading">¶</a></h3>
<blockquote>
<div><p>Yes. Dataset structures are pretty much identical in <a class="reference external" href="http://cosmomvpa.org">CoSMoMVPA</a> (<a class="reference external" href="http://pymvpa.org">PyMVPA</a> provided inspiration for the data structures). The <code class="docutils literal notranslate"><span class="pre">mvpa2/datasets/cosmo.py</span></code> module in <a class="reference external" href="http://pymvpa.org">PyMVPA</a> provides input and output support between CoSMoMVPA and PyMVPA datasets and neighborhoods. This means that, for example, searchlights defined in CoSMoMVPA can be run in PyMVPA (possibly benefitting from its multi-threaded implementation), and the results converted back to CoSMoMVPA format.</p>
</div></blockquote>
</section>
<section id="does-it-run-on-gnu-octave">
<h3><a class="toc-backref" href="#id14" role="doc-backlink">Does it run on GNU Octave?</a><a class="headerlink" href="#does-it-run-on-gnu-octave" title="Link to this heading">¶</a></h3>
<blockquote>
<div><p>Almost all functionality runs in <a class="reference external" href="https://www.gnu.org/software/octave/">Octave</a> 3.8, including unit tests through <a class="reference external" href="https://github.com/MOxUnit/MOxUnit">MOxUnit</a>, but there may be parts that function with limitations:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference external" href="http://www.brainvoyager.com">BrainVoyager</a> support through <a class="reference external" href="http://neuroelf.net">NeuroElf</a> is not supported, because <a class="reference external" href="http://neuroelf.net">NeuroElf</a> uses object-oriented features not supported by <a class="reference external" href="https://www.gnu.org/software/octave/">Octave</a>.</p></li>
</ul>
</div></blockquote>
</div></blockquote>
</section>
<section id="how-fast-does-it-run">
<h3><a class="toc-backref" href="#id15" role="doc-backlink">How fast does it run?</a><a class="headerlink" href="#how-fast-does-it-run" title="Link to this heading">¶</a></h3>
<blockquote>
<div><p><a class="reference external" href="http://cosmomvpa.org">CoSMoMVPA</a> is not a speed monster, but on limited hardware a searchlight using typical fMRI data takes one minute for simple analyses (correlation split-half), and a few minutes for more advanced analyses (classifier with cross-validation). The naive Bayes searchlights takes a few seconds for whole-brain fMRI per classification fold. Analyses on regions of interest are typically completed in seconds. Certain analysed (searchlight, multiple comparison correction) can be parallelized over multiple cores if a supported toolbox is available.</p>
</div></blockquote>
</section>
<section id="what-should-i-use-as-input-for-mvpa">
<h3><a class="toc-backref" href="#id16" role="doc-backlink">What should I use as input for MVPA?</a><a class="headerlink" href="#what-should-i-use-as-input-for-mvpa" title="Link to this heading">¶</a></h3>
<blockquote>
<div><p>We suggest the following:</p>
<ul>
<li><p>fMRI options:</p>
<blockquote>
<div><ul class="simple">
<li><p>Apply the GLM for each run separately, with separate predictors for each condition. Each run is a chunk, and each experimental condition is a target. You can use either beta estimates or t-statistics.</p></li>
<li><p>Split the data in halves (even and odd) and apply the GLM to each of these (i.e. treat the experiment as consisting of two ‘runs’). In this case there are two chunks, and the same number of unique targets as there are experimental conditions.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>MEEG options:</p>
<blockquote>
<div><ul>
<li><p>Preprocess the data (e.g. bandpassing, artifact rejection, downsampling).</p></li>
<li><p>For chunk assignment, either:</p>
<blockquote>
<div><ul class="simple">
<li><p>Assign chunks based on the run number.</p></li>
<li><p>If the data in different trials in the same run can be assumed to be independent, use unique chunk values for each trial. If that gives you a lot of chunks (which makes crossvalidation slow), use <a class="reference internal" href="matlab/cosmo_chunkize.html#cosmo-chunkize"><span class="std std-ref">cosmo chunkize</span></a>.</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</section>
<section id="who-are-the-developers-of-cosmomvpa">
<h3><a class="toc-backref" href="#id17" role="doc-backlink">Who are the developers of CoSMoMVPA?</a><a class="headerlink" href="#who-are-the-developers-of-cosmomvpa" title="Link to this heading">¶</a></h3>
<blockquote>
<div><p>Currently the developers are Nikolaas N. Oosterhof and Andrew C. Connolly. In the code you may find their initials (<code class="docutils literal notranslate"><span class="pre">NNO</span></code>, <code class="docutils literal notranslate"><span class="pre">ACC</span></code>) in commented header sections.</p>
</div></blockquote>
</section>
<section id="which-classifiers-are-available">
<h3><a class="toc-backref" href="#id18" role="doc-backlink">Which classifiers are available?</a><a class="headerlink" href="#which-classifiers-are-available" title="Link to this heading">¶</a></h3>
<blockquote>
<div><ul class="simple">
<li><p>Naive Bayes (<a class="reference internal" href="matlab/cosmo_classify_naive_bayes.html#cosmo-classify-naive-bayes"><span class="std std-ref">cosmo classify naive bayes</span></a>).</p></li>
<li><p>Nearest neighbor (<a class="reference internal" href="matlab/cosmo_classify_nn.html#cosmo-classify-nn"><span class="std std-ref">cosmo classify nn</span></a>).</p></li>
<li><p>k-nearest neighbor (<a class="reference internal" href="matlab/cosmo_classify_knn.html#cosmo-classify-knn"><span class="std std-ref">cosmo classify knn</span></a>).</p></li>
<li><p>Support Vector Machine (<a class="reference internal" href="matlab/cosmo_classify_svm.html#cosmo-classify-svm"><span class="std std-ref">cosmo classify svm</span></a>); requires the Matlab <code class="docutils literal notranslate"><span class="pre">stats</span></code> or <code class="docutils literal notranslate"><span class="pre">bioinfo</span></code> toolbox, or <a class="reference external" href="http://www.csie.ntu.edu.tw/~cjlin/libsvm/">LIBSVM</a>.</p></li>
<li><p>Linear Discriminant Analysis (<a class="reference internal" href="matlab/cosmo_classify_lda.html#cosmo-classify-lda"><span class="std std-ref">cosmo classify lda</span></a>).</p></li>
</ul>
</div></blockquote>
</section>
<section id="which-platforms-does-it-support">
<h3><a class="toc-backref" href="#id19" role="doc-backlink">Which platforms does it support?</a><a class="headerlink" href="#which-platforms-does-it-support" title="Link to this heading">¶</a></h3>
<blockquote>
<div><p>It has been tested with Windows, Mac and Linux.</p>
</div></blockquote>
</section>
<section id="what-future-features-can-be-expected">
<h3><a class="toc-backref" href="#id20" role="doc-backlink">What future features can be expected?</a><a class="headerlink" href="#what-future-features-can-be-expected" title="Link to this heading">¶</a></h3>
<blockquote>
<div><p>Time permitting, there are some features that may be added in the future:</p>
<ul class="simple">
<li><p>Snippets of useful code on the website.</p></li>
</ul>
</div></blockquote>
</section>
<section id="how-can-i-contact-the-developers-directly">
<h3><a class="toc-backref" href="#id21" role="doc-backlink">How can I contact the developers directly?</a><a class="headerlink" href="#how-can-i-contact-the-developers-directly" title="Link to this heading">¶</a></h3>
<blockquote>
<div><p>Please send an email to a&#64;c or b&#64;d, where a=andrew.c.connolly, b=n.n.oosterhof, c=dartmouth.edu, googlemail.com.</p>
</div></blockquote>
</section>
<section id="is-there-a-mailinglist">
<h3><a class="toc-backref" href="#id22" role="doc-backlink">Is there a mailinglist?</a><a class="headerlink" href="#is-there-a-mailinglist" title="Link to this heading">¶</a></h3>
<blockquote>
<div><p>There is the <a class="reference external" href="https://groups.google.com/forum/#!forum/cosmomvpa">CoSMoMVPA Google group</a>.</p>
</div></blockquote>
</section>
<section id="why-do-you-encourage-balanced-partitions">
<h3><a class="toc-backref" href="#id23" role="doc-backlink">Why do you encourage balanced partitions?</a><a class="headerlink" href="#why-do-you-encourage-balanced-partitions" title="Link to this heading">¶</a></h3>
<blockquote>
<div><p>‘I noticed that CoSMoMVPA heavily ‘encourages’ balanced class distributions (with equal number of samples in each class), and recommends to remove data to balance; why?’</p>
</div></blockquote>
<p>TL;DR: it’s much simpler and you don’t lose much by enforcing balanced partitions.</p>
<p>Longer version:the main reason for encouraging (almost enforcing) balanced partitions is a combination of simplicity and avoiding mistakes with ‘above chance’ classification.
It is considerably simple when chance is 1/c, with c the number of classes; in particular, this simplifies second level (group) analysis and allows for a relatively quick Monte Carlo based multiple-comparison correction through sign-swapping (as implemented in <a class="reference internal" href="matlab/cosmo_montecarlo_cluster_stat.html#cosmo-montecarlo-cluster-stat"><span class="std std-ref">cosmo montecarlo cluster stat</span></a>).
In addition, most paradigms use quite balanced designs anyway, so you do not loose much trials by enforcing balancing. If not using all trials would be a concern, one can reuse the same samples multiple times in different cross-validation folds through cosmo_balance_partitions with the ‘nrepeats’ or ‘nmin’ arguments.</p>
</section>
<section id="does-the-lda-linear-discriminant-analysis-classifier-use-shrinkage-normalization">
<h3><a class="toc-backref" href="#id24" role="doc-backlink">Does the LDA (linear discriminant analysis) classifier use shrinkage / normalization?</a><a class="headerlink" href="#does-the-lda-linear-discriminant-analysis-classifier-use-shrinkage-normalization" title="Link to this heading">¶</a></h3>
<p>Yes, the LDA classifier (<a class="reference internal" href="matlab/cosmo_classify_lda.html#cosmo-classify-lda"><span class="std std-ref">cosmo classify lda</span></a>) uses shrinkage / normalization. This classifier was already used in  <span id="id2">[<a class="reference internal" href="references.html#id20" title="Oosterhof, N. N., Wiestler, T., Downing, P. E., and Diedrichsen, J. A comparison of volume-based and surface-based multi-voxel pattern analysis. NeuroImage, 56(2):593–600, May 2011.">OWDD11</a>]</span>, where we wrote:</p>
<p>‘Because typically the number of voxels in selected regions was larger than the number of beta-estimates from the GLM, the estimate of the covariance matrix is rank deficient. We therefore regularized the matrix by adding the identity matrix scaled by one percent of the mean of the diagonal elements.’</p>
<p>Note that the regularization value of one percent is a parameter which can be adjusted in (<a class="reference internal" href="matlab/cosmo_classify_lda.html#cosmo-classify-lda"><span class="std std-ref">cosmo classify lda</span></a>).</p>
<p>At some point some effort was put in supporting a fancier shrinkage method (<span id="id3">[<a class="reference internal" href="references.html#id16" title="Ledoit, O. and Wolf, M. Honey, i shrunk the sample covariance matrix. The Journal of Portfolio Management, 30(4):110–119, 2004. doi:10.3905/jpm.2004.110.">LW04</a>]</span>), but this implementation for CoSMoMVPA was not completed. Currently it has low priority as the currently used regularisation seems to work quite well, but Pull Requests with such a feature will definitely be considered.</p>
</section>
</section>
<section id="how-do-i">
<h2><a class="toc-backref" href="#id25" role="doc-backlink">How do I …</a><a class="headerlink" href="#how-do-i" title="Link to this heading">¶</a></h2>
<nav class="contents local" id="id4">
<ul class="simple">
<li><p><a class="reference internal" href="#find-the-correspondence-between-voxel-indices-in-afni-and-feature-indices-in-cosmomvpa" id="id63">Find the correspondence between voxel indices in AFNI and feature indices in CoSMoMVPA</a></p></li>
<li><p><a class="reference internal" href="#get-ecog-data-in-a-cosmomvpa-struct" id="id64">Get ECoG data in a CoSMoMVPA struct</a></p></li>
<li><p><a class="reference internal" href="#get-temporal-data-in-a-cosmomvpa-struct" id="id65">Get temporal data in a CoSMoMVPA struct</a></p></li>
<li><p><a class="reference internal" href="#run-group-analysis" id="id66">Run group analysis</a></p></li>
<li><p><a class="reference internal" href="#make-an-intersection-mask-across-participants" id="id67">Make an intersection mask across participants</a></p></li>
<li><p><a class="reference internal" href="#compute-for-a-group-of-participants-who-were-scanned-with-mri-the-overlap-of-their-masks" id="id68">Compute for a group of participants who were scanned with MRI the overlap of their masks</a></p></li>
<li><p><a class="reference internal" href="#run-group-analysis-on-time-by-time-generalization-measures" id="id69">Run group analysis on time-by-time generalization measures</a></p></li>
<li><p><a class="reference internal" href="#use-libsvm" id="id70">Use LIBSVM</a></p></li>
<li><p><a class="reference internal" href="#use-surface-based-mapping-with-a-low-resolution-output-surface" id="id71">Use surface-based mapping with a low-resolution output surface</a></p></li>
<li><p><a class="reference internal" href="#correct-for-multiple-comparisons" id="id72">Correct for multiple comparisons</a></p></li>
<li><p><a class="reference internal" href="#do-cross-modal-decoding-across-three-modalities" id="id73">Do cross-modal decoding across three modalities</a></p></li>
<li><p><a class="reference internal" href="#compute-classification-accuracies-manually" id="id74">Compute classification accuracies manually</a></p></li>
<li><p><a class="reference internal" href="#make-a-merged-hemisphere-from-a-left-and-right-hemisphere" id="id75">Make a merged hemisphere from a left and right hemisphere</a></p></li>
<li><p><a class="reference internal" href="#merge-surface-data-from-two-hemispheres" id="id76">Merge surface data from two hemispheres</a></p></li>
<li><p><a class="reference internal" href="#visualize-and-store-multiple-fmri-volumes" id="id77">Visualize and store multiple fMRI volumes</a></p></li>
<li><p><a class="reference internal" href="#average-along-features-in-a-neighborhood" id="id78">Average along features in a neighborhood</a></p></li>
<li><p><a class="reference internal" href="#select-a-time-interval-in-an-meeg-dataset" id="id79">Select a time interval in an MEEG dataset</a></p></li>
<li><p><a class="reference internal" href="#select-a-particular-channel-type-in-an-meeg-dataset" id="id80">Select a particular channel type in an MEEG dataset</a></p></li>
<li><p><a class="reference internal" href="#use-only-a-subset-of-channels-for-my-analysis" id="id81">Use only a subset of channels for my analysis?</a></p></li>
<li><p><a class="reference internal" href="#should-i-fisher-transform-correlation-values" id="id82">Should I Fisher-transform correlation values?</a></p></li>
<li><p><a class="reference internal" href="#average-samples-in-a-deterministic-manner" id="id83">Average samples in a deterministic manner?</a></p></li>
<li><p><a class="reference internal" href="#select-only-a-subset-of-features-in-a-neighborhood" id="id84">Select only a subset of features in a neighborhood?</a></p></li>
<li><p><a class="reference internal" href="#use-multiple-comparison-correction-for-a-time-course" id="id85">Use multiple-comparison correction for a time course?</a></p></li>
<li><p><a class="reference internal" href="#classify-different-groups-of-participants-such-as-patients-versus-controls" id="id86">Classify different groups of participants (such as patients versus controls)?</a></p></li>
<li><p><a class="reference internal" href="#when-running-an-meeg-searchlight-have-the-same-channels-in-the-output-dataset-as-in-the-input-dataset" id="id87">When running an MEEG searchlight, have the same channels in the output dataset as in the input dataset?</a></p></li>
<li><p><a class="reference internal" href="#save-meeg-data-when-i-get-the-error-value-for-fdim-channel-label-is-not-supported" id="id88">Save MEEG data when I get the error “value for fdim channel label is not supported”?</a></p></li>
<li><p><a class="reference internal" href="#run-a-2-x-2-within-subject-anova" id="id89">Run a 2 x 2 within-subject ANOVA?</a></p></li>
<li><p><a class="reference internal" href="#use-a-fieldtrip-source-dataset-that-uses-a-fake-channel-structure" id="id90">Use a FieldTrip source dataset that uses a ‘fake’ channel structure</a></p></li>
<li><p><a class="reference internal" href="#run-cosmo-montecarlo-cluster-stat-on-a-cluster-with-multiple-nodes" id="id91">Run <cite>cosmo_montecarlo_cluster_stat</cite> on a cluster with multiple nodes</a></p></li>
<li><p><a class="reference internal" href="#why-should-i-consider-re-meaning-when-doing-representational-similarity-analysis-rsa" id="id92">Why should I consider re-meaning when doing representational similarity analysis (RSA)?</a></p></li>
<li><p><a class="reference internal" href="#import-brainstorm-data" id="id93">Import BrainStorm data</a></p></li>
<li><p><a class="reference internal" href="#compute-the-correlation-between-two-dissimilarity-matrices" id="id94">Compute the correlation between two dissimilarity matrices</a></p></li>
<li><p><a class="reference internal" href="#use-the-generalization-measure-with-different-durations-for-training-and-test-set" id="id95">Use the generalization measure with different durations for training and test set?</a></p></li>
<li><p><a class="reference internal" href="#get-the-classifier-weights-after-training-a-classifier" id="id96">Get the classifier weights after training a classifier?</a></p></li>
<li><p><a class="reference internal" href="#get-coordinates-of-voxels-in-a-cosmomvpa-fmri-dataset" id="id97">Get coordinates of voxels in a CoSMoMVPA fMRI dataset?</a></p></li>
<li><p><a class="reference internal" href="#compute-representational-similarity-across-chunks" id="id98">Compute representational similarity across chunks?</a></p></li>
<li><p><a class="reference internal" href="#run-group-analysis-on-time-generalization-results" id="id99">Run group analysis on time generalization results?</a></p></li>
</ul>
</nav>
<section id="find-the-correspondence-between-voxel-indices-in-afni-and-feature-indices-in-cosmomvpa">
<h3><a class="toc-backref" href="#id63" role="doc-backlink">Find the correspondence between voxel indices in AFNI and feature indices in CoSMoMVPA</a><a class="headerlink" href="#find-the-correspondence-between-voxel-indices-in-afni-and-feature-indices-in-cosmomvpa" title="Link to this heading">¶</a></h3>
<blockquote>
<div><p>In the AFNI GUI, you can view voxel indices by right-clicking on the coordinate field in the very left-top corner. Note that:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ds.fa.i</span></code>, <code class="docutils literal notranslate"><span class="pre">ds.fa.j</span></code>, and <code class="docutils literal notranslate"><span class="pre">ds.fa.k</span></code> are base-<code class="docutils literal notranslate"><span class="pre">1</span></code> whereas AFNI uses base-<code class="docutils literal notranslate"><span class="pre">0</span></code>. So, to convert AFNI’s <code class="docutils literal notranslate"><span class="pre">ijk</span></code>-indices to CoSMoMVPA’s, add <code class="docutils literal notranslate"><span class="pre">1</span></code> to AFNI’s coordinates.</p></li>
<li><p>CoSMoMVPA’s coordinates are valid for LPI-orientations, meaning that the first dimension is from left (lower values) to right (higher values), the second dimension is from posterior (lower values) to anterior (higher values), and the third dimension from inferior (lower values) to superior (higher values). To convert a dataset to LPI-orientation using AFNI, do:</p></li>
</ul>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>3dresample<span class="w"> </span>-orient<span class="w"> </span>LPI<span class="w"> </span>-inset<span class="w"> </span>my_data+orig<span class="w"> </span>-prefix<span class="w"> </span>my_data_lpi+orig.
</pre></div>
</div>
</div></blockquote>
</div></blockquote>
</section>
<section id="get-ecog-data-in-a-cosmomvpa-struct">
<span id="faq-get-ecog-data-in-cosmomvpa-struct"></span><h3><a class="toc-backref" href="#id64" role="doc-backlink">Get ECoG data in a CoSMoMVPA struct</a><a class="headerlink" href="#get-ecog-data-in-a-cosmomvpa-struct" title="Link to this heading">¶</a></h3>
<blockquote>
<div><blockquote>
<div><p>‘I have eCog data in a 3D array (<code class="docutils literal notranslate"><span class="pre">channels</span> <span class="pre">x</span> <span class="pre">time</span> <span class="pre">x</span> <span class="pre">trials</span></code>). How can I get this in a CoSMoMVPA struct?’</p>
</div></blockquote>
<p>Let’s assume there is data with those characteristics; here we generate synthetic data for illustration. This data has 7 time points, 3 channels, and 10 trials:</p>
<blockquote>
<div><div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">time_axis</span><span class="p">=</span><span class="o">-</span><span class="mf">.1</span><span class="p">:</span><span class="mf">.1</span><span class="p">:</span><span class="mf">.5</span><span class="p">;</span>
<span class="n">channel_axis</span><span class="p">={</span><span class="s">&#39;chan1&#39;</span><span class="p">,</span><span class="s">&#39;chan2&#39;</span><span class="p">,</span><span class="s">&#39;chan3&#39;</span><span class="p">};</span>

<span class="n">n_trials</span><span class="p">=</span><span class="mi">10</span><span class="p">;</span>
<span class="n">n_time</span><span class="p">=</span><span class="nb">numel</span><span class="p">(</span><span class="n">time_axis</span><span class="p">);</span>
<span class="n">n_channels</span><span class="p">=</span><span class="nb">numel</span><span class="p">(</span><span class="n">channel_axis</span><span class="p">);</span>

<span class="n">data</span><span class="p">=</span><span class="nb">randn</span><span class="p">([</span><span class="n">n_channels</span><span class="p">,</span><span class="n">n_time</span><span class="p">,</span><span class="n">n_trials</span><span class="p">]);</span><span class="w"> </span><span class="c">% Gaussian random data</span>
</pre></div>
</div>
</div></blockquote>
<p>Because in CoSMoMVPA, samples are in the first dimension, the order of the dimensions have to be shifted so that the <code class="docutils literal notranslate"><span class="pre">trials</span></code> (samples) dimension comes first:</p>
<blockquote>
<div><div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">data_samples_first_dim</span><span class="p">=</span><span class="nb">shiftdim</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>Now the data can be flattened to a CoSMoMVPA data struct with:</p>
<blockquote>
<div><div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">ds</span><span class="p">=</span><span class="n">cosmo_flatten</span><span class="p">(</span><span class="n">data_samples_first_dim</span><span class="p">,</span><span class="k">...</span>
<span class="w">                    </span><span class="p">{</span><span class="s">&#39;chan&#39;</span><span class="p">,</span><span class="s">&#39;time&#39;</span><span class="p">},</span><span class="k">...</span>
<span class="w">                    </span><span class="p">{</span><span class="n">channel_axis</span><span class="p">,</span><span class="n">time_axis</span><span class="p">});</span>
</pre></div>
</div>
</div></blockquote>
<p>Combinations of <code class="docutils literal notranslate"><span class="pre">chan</span></code> and <code class="docutils literal notranslate"><span class="pre">time</span></code> are the features of the dataset. For example, to see how informative the data is for different time points (across all channels), one could define a <a class="reference internal" href="matlab/cosmo_interval_neighborhood.html#cosmo-interval-neighborhood"><span class="std std-ref">cosmo interval neighborhood</span></a> for the time dimension and run a <a class="reference internal" href="matlab/cosmo_searchlight.html#cosmo-searchlight"><span class="std std-ref">searchlight</span></a>.</p>
<p>If one would only want to consider the <code class="docutils literal notranslate"><span class="pre">chan</span></code> dimension as features, and consider <code class="docutils literal notranslate"><span class="pre">time</span></code> as a sample dimension, do:</p>
<blockquote>
<div><div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">ds_time_in_sample_dim</span><span class="p">=</span><span class="n">cosmo_dim_transpose</span><span class="p">(</span><span class="n">ds</span><span class="p">,{</span><span class="s">&#39;time&#39;</span><span class="p">},</span><span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>When the data is in this form, one can analyse how well information <a class="reference internal" href="matlab/demo_meeg_timeseries_generalization.html#demo-meeg-timeseries-generalization"><span class="std std-ref">generalizes over time</span></a> .</p>
</div></blockquote>
</section>
<section id="get-temporal-data-in-a-cosmomvpa-struct">
<h3><a class="toc-backref" href="#id65" role="doc-backlink">Get temporal data in a CoSMoMVPA struct</a><a class="headerlink" href="#get-temporal-data-in-a-cosmomvpa-struct" title="Link to this heading">¶</a></h3>
<blockquote>
<div><blockquote>
<div><p>‘Using MEEG dataset, using custom written software I have precomputed RSA correlations across channels for a group of subjects for each timepoints; the result is <code class="docutils literal notranslate"><span class="pre">data</span></code> matrix of size <code class="docutils literal notranslate"><span class="pre">17x300</span></code>, corresponding to <code class="docutils literal notranslate"><span class="pre">subjects</span> <span class="pre">x</span> <span class="pre">time</span></code>. How can I get this in a CoSMoMVPA dataset struct, and use <a class="reference internal" href="matlab/cosmo_montecarlo_cluster_stat.html#cosmo-montecarlo-cluster-stat"><span class="std std-ref">cosmo montecarlo cluster stat</span></a> for multiple comparison correction?’</p>
</div></blockquote>
<p>We will generate some (random) data with these characteristics:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="c">% generate pseudo-random data</span>
<span class="n">data</span><span class="p">=</span><span class="n">cosmo_rand</span><span class="p">(</span><span class="mi">17</span><span class="p">,</span><span class="mi">300</span><span class="p">);</span>

<span class="c">% set the time (in seconds) for each column</span>
<span class="c">% Here, the first time point is 200ms pre-stimulus</span>
<span class="c">% and each time step is 2ms. The last time point</span>
<span class="c">% is at 398 ms</span>
<span class="n">time_axis</span><span class="p">=</span><span class="o">-</span><span class="mf">.2</span><span class="p">:</span><span class="mf">.002</span><span class="p">:</span><span class="mf">.398</span><span class="p">;</span>
</pre></div>
</div>
<p>To get the data in a dataset structure, a similar approach is followed as in another FAQ entry (<a class="reference internal" href="#faq-get-ecog-data-in-cosmomvpa-struct"><span class="std std-ref">Get ECoG data in a CoSMoMVPA struct</span></a>) - but note that there is only a time axis here to use as a feature dimension:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">ds</span><span class="p">=</span><span class="n">cosmo_flatten</span><span class="p">(</span><span class="n">data</span><span class="p">,{</span><span class="s">&#39;time&#39;</span><span class="p">},{</span><span class="n">time_axis</span><span class="p">},</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>Clustering with  <a class="reference internal" href="matlab/cosmo_montecarlo_cluster_stat.html#cosmo-montecarlo-cluster-stat"><span class="std std-ref">cosmo montecarlo cluster stat</span></a> requires (as usual) a clustering neighborhood computed by <a class="reference internal" href="matlab/cosmo_cluster_neighborhood.html#cosmo-cluster-neighborhood"><span class="std std-ref">cosmo cluster neighborhood</span></a>:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="c">% cluster neighborhood over time points</span>
<span class="n">cl_nh</span><span class="p">=</span><span class="n">cosmo_cluster_neighborhood</span><span class="p">(</span><span class="n">ds</span><span class="p">);</span>
</pre></div>
</div>
<p>To use <a class="reference internal" href="matlab/cosmo_montecarlo_cluster_stat.html#cosmo-montecarlo-cluster-stat"><span class="std std-ref">cosmo montecarlo cluster stat</span></a>, it is required to set targets and chunks. In this case there is a single sample per subject, which is reflected in <code class="docutils literal notranslate"><span class="pre">.sa.targets</span></code> and <code class="docutils literal notranslate"><span class="pre">.sa.chunks</span></code>.</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">n_subjects</span><span class="p">=</span><span class="nb">size</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="n">ds</span><span class="p">.</span><span class="n">sa</span><span class="p">.</span><span class="n">targets</span><span class="p">=</span><span class="nb">ones</span><span class="p">(</span><span class="n">n_subjects</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="n">ds</span><span class="p">.</span><span class="n">sa</span><span class="p">.</span><span class="n">chunks</span><span class="p">=(</span><span class="mi">1</span><span class="p">:</span><span class="n">n_subjects</span><span class="p">)</span><span class="o">&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>To run  <a class="reference internal" href="matlab/cosmo_montecarlo_cluster_stat.html#cosmo-montecarlo-cluster-stat"><span class="std std-ref">cosmo montecarlo cluster stat</span></a> it is required to set the number of iterations and (for a one-sample t-test) the expected mean under the null hypothesis.</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">opt</span><span class="p">=</span><span class="nb">struct</span><span class="p">();</span>

<span class="c">% use at least 10000 iterations for publication-quality analyses</span>
<span class="n">opt</span><span class="p">.</span><span class="n">niter</span><span class="p">=</span><span class="mi">10000</span><span class="p">;</span>

<span class="c">% expected mean under null hypothesis.</span>
<span class="c">% For this example (pre-computed RSA correlation values)</span>
<span class="c">% the expected mean is zero.</span>
<span class="n">opt</span><span class="p">.</span><span class="n">h0_mean</span><span class="p">=</span><span class="mi">0</span><span class="p">;</span>

<span class="c">% compute z-scores after TFCE correction</span>
<span class="n">tfce_z_ds</span><span class="p">=</span><span class="n">cosmo_montecarlo_cluster_stat</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span><span class="n">cl_nh</span><span class="p">,</span><span class="n">opt</span><span class="p">);</span>
</pre></div>
</div>
<p>Note that clusters are computed across the time dimension, so if a cluster survives between (say) 100 and 150 ms, one <em>cannot</em> infer that at 100 ms there is significant information present that explains the non-zero correlations. Instead, the inferences can only be made at the cluster level, i.e. there is evidence for significant information at a cluster of time points. To be able to make inferences at the individual time point level, use a cluster neighborhood that does not connect clusters across the time dimension:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="c">% cluster neighborhood not connecting time points</span>
<span class="n">cl_nh_not_over_time</span><span class="p">=</span><span class="n">cosmo_cluster_neighborhood</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span><span class="s">&#39;time&#39;</span><span class="p">,</span><span class="nb">false</span><span class="p">);</span>
</pre></div>
</div>
<p>in which case a significant feature at (say) 100 ms can directly be interpreted as evidence for information being present at 100 ms. However, such a test is less sensitive than a neighborhood that connects features across time.</p>
</div></blockquote>
</section>
<section id="run-group-analysis">
<span id="faq-run-group-analysis"></span><h3><a class="toc-backref" href="#id66" role="doc-backlink">Run group analysis</a><a class="headerlink" href="#run-group-analysis" title="Link to this heading">¶</a></h3>
<blockquote>
<div><blockquote>
<div><p>‘I ran an fMRI searchlight analysis using <a class="reference internal" href="matlab/cosmo_searchlight.html#cosmo-searchlight"><span class="std std-ref">cosmo searchlight</span></a> with <a class="reference internal" href="matlab/cosmo_spherical_neighborhood.html#cosmo-spherical-neighborhood"><span class="std std-ref">cosmo spherical neighborhood</span></a> and got a result map for a single participant. Now I want to repeat this for my other participants, and then do a group analysis. It is my understanding that I should use <a class="reference internal" href="matlab/cosmo_montecarlo_cluster_stat.html#cosmo-montecarlo-cluster-stat"><span class="std std-ref">cosmo montecarlo cluster stat</span></a>, but the documentation refers to <a class="reference internal" href="matlab/cosmo_cluster_neighborhood.html#cosmo-cluster-neighborhood"><span class="std std-ref">cosmo cluster neighborhood</span></a>.’</p>
</div></blockquote>
<p>Indeed <a class="reference internal" href="matlab/cosmo_cluster_neighborhood.html#cosmo-cluster-neighborhood"><span class="std std-ref">cosmo cluster neighborhood</span></a> should be used with <a class="reference internal" href="matlab/cosmo_montecarlo_cluster_stat.html#cosmo-montecarlo-cluster-stat"><span class="std std-ref">cosmo montecarlo cluster stat</span></a>, because that neighborhood function returns a neighborhood structure indicating which features (voxels) are next to each other. This is different from, say, a spherical neighborhood with a radius of 3 voxels.</p>
<blockquote>
<div><p>(Technically <a class="reference internal" href="matlab/cosmo_cluster_neighborhood.html#cosmo-cluster-neighborhood"><span class="std std-ref">cosmo cluster neighborhood</span></a>, when applied on a typical fMRI dataset (that is, without other feature dimensions), returns by default a neighborhood that is equivalent to a spherical neighborhood with a radius between <code class="docutils literal notranslate"><span class="pre">sqrt(3)</span></code> and <code class="docutils literal notranslate"><span class="pre">2</span></code>, meaning that under the assumption of isotropocy, voxels are neighbors if they share at least a vertex (corner).</p>
<p>Also, <a class="reference internal" href="matlab/cosmo_cluster_neighborhood.html#cosmo-cluster-neighborhood"><span class="std std-ref">cosmo cluster neighborhood</span></a> works on other types of datasets, including surface-based fMRI, timelocked MEEG, and time-frequency MEEG.)</p>
</div></blockquote>
<p>Assuming that <code class="docutils literal notranslate"><span class="pre">result</span></code> was constructed as above, a group analysis using Threshold-Free Cluster Enhancement and using 1000 permutations can now by done quite easily. For a one-sample t-test (one sample per participant, it is however required to specify the mean under the null hypothesis. When the <a class="reference internal" href="matlab/cosmo_correlation_measure.html#cosmo-correlation-measure"><span class="std std-ref">cosmo correlation measure</span></a> or <a class="reference internal" href="matlab/cosmo_target_dsm_corr_measure.html#cosmo-target-dsm-corr-measure"><span class="std std-ref">cosmo target dsm corr measure</span></a> is used, this is typically zero, whereas for <a class="reference internal" href="matlab/cosmo_crossvalidation_measure.html#cosmo-crossvalidation-measure"><span class="std std-ref">cosmo crossvalidation measure</span></a>, this is typically 1 divided by the number of classes (e.g. <code class="docutils literal notranslate"><span class="pre">0.25</span></code> for 4-class discrimination).</p>
<blockquote>
<div><div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="c">% one-sample t-test against 0</span>
<span class="c">% (for representational similarity analysis)</span>
<span class="n">h0_mean</span><span class="p">=</span><span class="mi">0</span><span class="p">;</span>

<span class="c">% number of null iterations.</span>
<span class="c">% values of at least 10,000 are recommended for publication-quality</span>
<span class="n">niter</span><span class="p">=</span><span class="mi">1000</span><span class="p">;</span>

<span class="c">%</span>
<span class="c">% Set neighborhood for clustering</span>
<span class="n">cluster_nbrhood</span><span class="p">=</span><span class="n">cosmo_cluster_neighborhood</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>

<span class="n">stat_map</span><span class="p">=</span><span class="n">cosmo_montecarlo_cluster_stat</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">cluster_nbrhood</span><span class="p">,</span><span class="k">...</span>
<span class="w">                                        </span><span class="s">&#39;niter&#39;</span><span class="p">,</span><span class="w"> </span><span class="n">niter</span><span class="p">,</span><span class="k">...</span>
<span class="w">                                        </span><span class="s">&#39;h0_mean&#39;</span><span class="p">,</span><span class="w"> </span><span class="n">h0_mean</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
</div></blockquote>
</section>
<section id="make-an-intersection-mask-across-participants">
<h3><a class="toc-backref" href="#id67" role="doc-backlink">Make an intersection mask across participants</a><a class="headerlink" href="#make-an-intersection-mask-across-participants" title="Link to this heading">¶</a></h3>
<blockquote>
<div><p>‘I ran my analysis for multiple participants, each with their own mask. Now I want to do group analysis, but combining the data using <a class="reference internal" href="matlab/cosmo_stack.html#cosmo-stack"><span class="std std-ref">cosmo stack</span></a> gives an error because feature attributes do not match. How can I combine data across participants?</p>
</div></blockquote>
<p>If <code class="docutils literal notranslate"><span class="pre">ds_cell</span></code> is a cell so that <code class="docutils literal notranslate"><span class="pre">ds_cell{k}</span></code> contains the dataset from the <code class="docutils literal notranslate"><span class="pre">k</span></code>-th participant, an intersection (based on features common across participants) can be computed though:</p>
<blockquote>
<div><div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">idxs</span><span class="p">,</span><span class="n">ds_intersect_cell</span><span class="p">]=</span><span class="n">cosmo_mask_dim_intersect</span><span class="p">(</span><span class="n">ds_cell</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>For (second level) group analysis, in general, it is a good idea to assign <code class="docutils literal notranslate"><span class="pre">chunks</span></code> (if not done already) and <code class="docutils literal notranslate"><span class="pre">targets</span></code>. The general approach to setting chunks is by indicating that data from different participants is assumed to be independent; for setting targets, see the help of <a class="reference internal" href="matlab/cosmo_stat.html#cosmo-stat"><span class="std std-ref">cosmo stat</span></a>:</p>
<blockquote>
<div><div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">n_subjects</span><span class="p">=</span><span class="nb">numel</span><span class="p">(</span><span class="n">ds_intersect_cell</span><span class="p">);</span>
<span class="k">for</span><span class="w"> </span><span class="n">subject_i</span><span class="p">=</span><span class="mi">1</span><span class="p">:</span><span class="n">n_subjects</span>
<span class="w">    </span><span class="c">% get dataset</span>
<span class="w">    </span><span class="n">ds</span><span class="p">=</span><span class="n">ds_intersect_cell</span><span class="p">{</span><span class="n">subject_i</span><span class="p">];</span>

<span class="w">    </span><span class="c">% assign chunks</span>
<span class="w">    </span><span class="n">n_samples</span><span class="p">=</span><span class="nb">size</span><span class="p">(</span><span class="n">ds</span><span class="p">.</span><span class="n">samples</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="n">ds</span><span class="p">.</span><span class="n">sa</span><span class="p">.</span><span class="n">chunks</span><span class="p">=</span><span class="nb">ones</span><span class="p">(</span><span class="n">nsamples</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">subject_i</span><span class="p">;</span>

<span class="w">    </span><span class="c">% assign targets</span>
<span class="w">    </span><span class="c">% Your code comes here; see cosmo_stat on how to assign</span>
<span class="w">    </span><span class="c">% targets depending on subsequent analysis</span>
<span class="w">    </span><span class="c">% (one-sample or two-sample t-test, or one-way or</span>
<span class="w">    </span><span class="c">% repeated-measures ANOVA).</span>


<span class="w">    </span><span class="c">% store results</span>
<span class="w">    </span><span class="n">ds_intersect_cell</span><span class="p">{</span><span class="n">subject_i</span><span class="p">}=</span><span class="n">ds</span><span class="p">;</span>
<span class="k">end</span>
</pre></div>
</div>
</div></blockquote>
<p>The the resulting datasets can be combined through:</p>
<blockquote>
<div><div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">ds_all</span><span class="p">=</span><span class="n">cosmo_stack</span><span class="p">(</span><span class="n">ds_intersect_cell</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>Note: The above line may give an error <code class="docutils literal notranslate"><span class="pre">non-unique</span> <span class="pre">elements</span> <span class="pre">in</span> <span class="pre">fa.X</span></code>, with <code class="docutils literal notranslate"><span class="pre">X</span></code> some feature attribute such as <code class="docutils literal notranslate"><span class="pre">center_ids</span></code> or <code class="docutils literal notranslate"><span class="pre">radius</span></code>. This is to be expected if the datasets are the result from another analysis, such as <a class="reference internal" href="matlab/cosmo_searchlight.html#cosmo-searchlight"><span class="std std-ref">cosmo searchlight</span></a>. In that case, the data can be combined using:</p>
<blockquote>
<div><div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">ds_all</span><span class="p">=</span><span class="n">cosmo_stack</span><span class="p">(</span><span class="n">ds_intersect_cell</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="s">&#39;drop_nonunique&#39;</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
</section>
<section id="compute-for-a-group-of-participants-who-were-scanned-with-mri-the-overlap-of-their-masks">
<h3><a class="toc-backref" href="#id68" role="doc-backlink">Compute for a group of participants who were scanned with MRI the overlap of their masks</a><a class="headerlink" href="#compute-for-a-group-of-participants-who-were-scanned-with-mri-the-overlap-of-their-masks" title="Link to this heading">¶</a></h3>
<blockquote>
<div><p>‘I analyzed data for individual fMRI participants that are all in a common MNI space, but with individual masks. When using <a class="reference internal" href="matlab/cosmo_mask_dim_intersect.html#cosmo-mask-dim-intersect"><span class="std std-ref">cosmo mask dim intersect</span></a> I seem to lose about a third of the voxels present in each participant. How can I visualize which voxels are not shared across participants?’</p>
</div></blockquote>
<p>The following code illustrates how this can be done, using synthetic data.</p>
<blockquote>
<div><div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">keep_ratio</span><span class="p">=</span><span class="mf">0.95</span><span class="p">;</span>
<span class="n">n_subj</span><span class="p">=</span><span class="mi">10</span><span class="p">;</span>

<span class="c">% simulate data for all subjects with their masks mostly overlapping</span>
<span class="n">ds_cell</span><span class="p">=</span><span class="nb">cell</span><span class="p">(</span><span class="n">n_subj</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="k">for</span><span class="w"> </span><span class="n">k</span><span class="p">=</span><span class="mi">1</span><span class="p">:</span><span class="n">n_subj</span>
<span class="w">    </span><span class="n">ds_full</span><span class="p">=</span><span class="n">cosmo_synthetic_dataset</span><span class="p">(</span><span class="s">&#39;seed&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="s">&#39;size&#39;</span><span class="p">,</span><span class="s">&#39;big&#39;</span><span class="p">);</span>

<span class="w">    </span><span class="n">n_features</span><span class="p">=</span><span class="nb">size</span><span class="p">(</span><span class="n">ds_full</span><span class="p">.</span><span class="n">samples</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
<span class="w">    </span><span class="n">keep</span><span class="p">=</span><span class="n">cosmo_randperm</span><span class="p">(</span><span class="n">n_features</span><span class="p">,</span><span class="nb">round</span><span class="p">(</span><span class="n">n_features</span><span class="o">*</span><span class="n">keep_ratio</span><span class="p">));</span>
<span class="w">    </span><span class="n">ds</span><span class="p">=</span><span class="n">cosmo_slice</span><span class="p">(</span><span class="n">ds_full</span><span class="p">,</span><span class="n">keep</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>

<span class="w">    </span><span class="n">ds_cell</span><span class="p">{</span><span class="n">k</span><span class="p">}=</span><span class="n">ds</span><span class="p">;</span>
<span class="k">end</span>

<span class="c">% do simple intersection mask</span>
<span class="p">[</span><span class="n">idxs</span><span class="p">,</span><span class="n">ds_cell_common</span><span class="p">]=</span><span class="n">cosmo_mask_dim_intersect</span><span class="p">(</span><span class="n">ds_cell</span><span class="p">);</span>
<span class="n">ds_common</span><span class="p">=</span><span class="n">cosmo_stack</span><span class="p">(</span><span class="n">ds_cell_common</span><span class="p">);</span>

<span class="nb">fprintf</span><span class="p">(</span><span class="s">&#39;Ratio in common: %d / %d\n&#39;</span><span class="p">,</span><span class="nb">size</span><span class="p">(</span><span class="n">ds_common</span><span class="p">.</span><span class="n">samples</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="n">n_features</span><span class="p">);</span>

<span class="c">% see how often each voxel was in the mask for each participant</span>
<span class="k">for</span><span class="w"> </span><span class="n">k</span><span class="p">=</span><span class="mi">1</span><span class="p">:</span><span class="n">n_subj</span>
<span class="w">    </span><span class="n">ds_single_volume</span><span class="p">=</span><span class="n">cosmo_slice</span><span class="p">(</span><span class="n">ds_cell</span><span class="p">{</span><span class="n">k</span><span class="p">},</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="n">ds_single_volume</span><span class="p">.</span><span class="n">samples</span><span class="p">(:)=</span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="n">ni</span><span class="p">=</span><span class="n">cosmo_map2fmri</span><span class="p">(</span><span class="n">ds_single_volume</span><span class="p">,</span><span class="s">&#39;-nii&#39;</span><span class="p">);</span>
<span class="w">    </span><span class="n">img</span><span class="p">=</span><span class="n">ni</span><span class="p">.</span><span class="n">img</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">k</span><span class="o">==</span><span class="mi">1</span>
<span class="w">        </span><span class="n">img_sum</span><span class="p">=</span><span class="nb">zeros</span><span class="p">(</span><span class="nb">size</span><span class="p">(</span><span class="n">img</span><span class="p">));</span>
<span class="w">    </span><span class="k">end</span>

<span class="w">    </span><span class="n">img_sum</span><span class="p">=</span><span class="n">img_sum</span><span class="o">+</span><span class="n">img</span><span class="p">;</span>
<span class="k">end</span>

<span class="c">% convert to a ratio between 0 and 1 (for each voxel)</span>
<span class="n">ni</span><span class="p">.</span><span class="n">img</span><span class="p">=</span><span class="n">img_sum</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">n_subj</span><span class="p">;</span>

<span class="c">% convert to dataset structure</span>
<span class="n">ds_ratio</span><span class="p">=</span><span class="n">cosmo_fmri_dataset</span><span class="p">(</span><span class="n">ni</span><span class="p">);</span>

<span class="c">% the ds_ratio dataset can be visualized as shown here,</span>
<span class="c">% or stored to disc using cosmo_map2fmri</span>
<span class="n">cosmo_plot_slices</span><span class="p">(</span><span class="n">ds_ratio</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
</section>
<section id="run-group-analysis-on-time-by-time-generalization-measures">
<h3><a class="toc-backref" href="#id69" role="doc-backlink">Run group analysis on time-by-time generalization measures</a><a class="headerlink" href="#run-group-analysis-on-time-by-time-generalization-measures" title="Link to this heading">¶</a></h3>
<blockquote>
<div><blockquote>
<div><p>‘I used <a class="reference internal" href="matlab/cosmo_dim_generalization_measure.html#cosmo-dim-generalization-measure"><span class="std std-ref">cosmo dim generalization measure</span></a> on MEEG data to get time-by-time generalization results. How do I run group analysis with cluster correction (<a class="reference internal" href="matlab/cosmo_montecarlo_cluster_stat.html#cosmo-montecarlo-cluster-stat"><span class="std std-ref">cosmo montecarlo cluster stat</span></a>) on these?’</p>
<p>Let’s assume the data from all subjects is stored in a cell <code class="docutils literal notranslate"><span class="pre">ds_cell</span></code>, with <code class="docutils literal notranslate"><span class="pre">ds_cell{k}</span></code> is a dataset struct with the output from  <a class="reference internal" href="matlab/cosmo_dim_generalization_measure.html#cosmo-dim-generalization-measure"><span class="std std-ref">cosmo dim generalization measure</span></a> for the <code class="docutils literal notranslate"><span class="pre">k</span></code>-th subject. Each dataset has the <code class="docutils literal notranslate"><span class="pre">train_time</span></code> and <code class="docutils literal notranslate"><span class="pre">test_time</span></code> attribute in the sample dimension, and they have to be moved to the feature dimension to use <a class="reference internal" href="matlab/cosmo_montecarlo_cluster_stat.html#cosmo-montecarlo-cluster-stat"><span class="std std-ref">cosmo montecarlo cluster stat</span></a>):</p>
<blockquote>
<div><div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">n_subjects</span><span class="p">=</span><span class="nb">numel</span><span class="p">(</span><span class="n">ds_cell</span><span class="p">);</span>
<span class="n">ds_cell_tr</span><span class="p">=</span><span class="nb">cell</span><span class="p">(</span><span class="n">n_subjects</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="k">for</span><span class="w"> </span><span class="n">k</span><span class="p">=</span><span class="mi">1</span><span class="p">:</span><span class="n">n_subjects</span>
<span class="w">    </span><span class="n">ds_cell_tr</span><span class="p">{</span><span class="n">k</span><span class="p">}=</span><span class="n">cosmo_dim_transpose</span><span class="p">(</span><span class="n">ds_cell</span><span class="p">{</span><span class="n">k</span><span class="p">},</span><span class="k">...</span>
<span class="w">                        </span><span class="p">{</span><span class="s">&#39;train_time&#39;</span><span class="p">,</span><span class="s">&#39;test_time&#39;</span><span class="p">},</span><span class="mi">2</span><span class="p">);</span>
<span class="k">end</span>
</pre></div>
</div>
</div></blockquote>
</div></blockquote>
<p>Then, it is almost always necessary to set the <code class="docutils literal notranslate"><span class="pre">.sa.targets</span></code> and <code class="docutils literal notranslate"><span class="pre">.sa.chunks</span></code> attributes. The former refers to conditions; the latter to (in this case) the subject. See <a class="reference internal" href="matlab/cosmo_montecarlo_cluster_stat.html#cosmo-montecarlo-cluster-stat"><span class="std std-ref">cosmo montecarlo cluster stat</span></a> how to define these generally for various tests. In the simple case of a one-sample t-test, these would be set as follows:</p>
<blockquote>
<div><blockquote>
<div><div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="n">k</span><span class="p">=</span><span class="mi">1</span><span class="p">:</span><span class="n">n_subjects</span>
<span class="w">    </span><span class="c">% here we assume a single output (sample) for each</span>
<span class="w">    </span><span class="c">% searchlight. For statistical analysis later, where</span>
<span class="w">    </span><span class="c">% we want to do a one-sample t-test, we set</span>
<span class="w">    </span><span class="c">% .sa.targets to 1 (any constant value will do) and</span>
<span class="w">    </span><span class="c">% .sa.chunks to the subject number.</span>
<span class="w">    </span><span class="c">% nsamples=size(result.samples,1);</span>
<span class="w">    </span><span class="c">%</span>
<span class="w">    </span><span class="c">% Notes:</span>
<span class="w">    </span><span class="c">% - these values can also be set after the analysis is run,</span>
<span class="w">    </span><span class="c">%   although that may be more error-prone</span>
<span class="w">    </span><span class="c">% - for other statistical tests, such as one-way ANOVA,</span>
<span class="w">    </span><span class="c">%   repeated-measures ANOVA, paired-sample t-test and</span>
<span class="w">    </span><span class="c">%   two-sample t-tests, chunks and targets have to be</span>
<span class="w">    </span><span class="c">%   set differently. See the documentation of</span>
<span class="w">    </span><span class="c">%   cosmo_montecarlo_cluster_stat for details.</span>

<span class="w">    </span><span class="n">ds_cell_tr</span><span class="p">{</span><span class="n">k</span><span class="p">}.</span><span class="n">sa</span><span class="p">.</span><span class="n">chunks</span><span class="p">=</span><span class="n">k</span><span class="p">;</span><span class="w">  </span><span class="c">% k-th subject</span>
<span class="w">    </span><span class="n">ds_cell_tr</span><span class="p">{</span><span class="n">k</span><span class="p">}.</span><span class="n">sa</span><span class="p">.</span><span class="n">targets</span><span class="p">=</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c">% all same condition</span>

<span class="k">end</span>
</pre></div>
</div>
</div></blockquote>
<p>and results would be joined into a single dataset by:</p>
<blockquote>
<div><div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">ds_tr</span><span class="p">=</span><span class="n">cosmo_stack</span><span class="p">(</span><span class="n">ds_cell_tr</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>Now group analysis can proceed using <a class="reference internal" href="matlab/cosmo_montecarlo_cluster_stat.html#cosmo-montecarlo-cluster-stat"><span class="std std-ref">cosmo montecarlo cluster stat</span></a> as described in <a class="reference internal" href="#faq-run-group-analysis">faq_run_group_analysis</a>.</p>
<p>To convert the output (say <code class="docutils literal notranslate"><span class="pre">stat_map</span></code>) from  <a class="reference internal" href="matlab/cosmo_montecarlo_cluster_stat.html#cosmo-montecarlo-cluster-stat"><span class="std std-ref">cosmo montecarlo cluster stat</span></a> to matrix form (time by time), do</p>
<blockquote>
<div><div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">labels</span><span class="p">,</span><span class="w"> </span><span class="nb">values</span><span class="p">]=</span><span class="n">cosmo_unflatten</span><span class="p">(</span><span class="n">stat_map</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
<span class="n">data_mat</span><span class="p">=</span><span class="nb">squeeze</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
</div></blockquote>
</div></blockquote>
</section>
<section id="use-libsvm">
<h3><a class="toc-backref" href="#id70" role="doc-backlink">Use LIBSVM</a><a class="headerlink" href="#use-libsvm" title="Link to this heading">¶</a></h3>
<p>Download <a class="reference external" href="http://www.csie.ntu.edu.tw/~cjlin/libsvm/">LIBSVM</a>, then in Matlab or Octave, do</p>
<blockquote>
<div><div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="nb">cd</span><span class="w"> </span><span class="n">libsvm</span><span class="p">;</span><span class="w"> </span><span class="c">% change this to the directory where you put LIBSVM</span>
<span class="nb">cd</span><span class="w"> </span><span class="n">matlab</span><span class="w">  </span><span class="c">% go to matlab sub-directory</span>
<span class="n">make</span><span class="w">       </span><span class="s">%</span><span class="w"> </span><span class="s">compile</span><span class="w"> </span><span class="s">libsvm</span><span class="w"> </span><span class="s">mex</span><span class="w"> </span><span class="s">functions</span><span class="p">;</span><span class="w"> </span><span class="n">requires</span><span class="w"> </span><span class="s">a</span><span class="w"> </span><span class="s">working</span><span class="w"> </span><span class="s">compiler</span>
<span class="nb">rmpath</span><span class="p">(</span><span class="nb">pwd</span><span class="p">)</span><span class="w">   </span><span class="c">% } ensure directory is on top</span>
<span class="nb">addpath</span><span class="p">(</span><span class="nb">pwd</span><span class="p">)</span><span class="w">  </span><span class="c">% } of the search path</span>

<span class="c">% verify it worked.</span>
<span class="n">cosmo_check_external</span><span class="p">(</span><span class="s">&#39;libsvm&#39;</span><span class="p">);</span><span class="w"> </span><span class="c">% should not give an error</span>
</pre></div>
</div>
</div></blockquote>
<ul class="simple">
<li><p>If the <code class="docutils literal notranslate"><span class="pre">make</span></code> command failed, make sure you are in the LIBSVM’s <code class="docutils literal notranslate"><span class="pre">matlab</span></code> subdirectory, and that you have a working <a class="reference external" href="http://it.mathworks.com/help/matlab/matlab_external/what-you-need-to-build-mex-files.html">compiler under Matlab</a> or <a class="reference external" href="https://www.gnu.org/software/octave/doc/interpreter/Getting-Started-with-Mex_002dFiles.html">compiler under Octave</a>.</p></li>
<li><p>If you want to store the path, you can also do</p></li>
</ul>
<blockquote>
<div><div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="nb">savepath</span>
</pre></div>
</div>
</div></blockquote>
<p>so that the next time you start Matlab or Octave, the correct path is used.</p>
<p>Matlab also provides an SVM implementation in the <code class="docutils literal notranslate"><span class="pre">stats</span></code> (and possible other) toolboxes, and the naming of the training functions are not compatible with LIBSVM. Thus, you can use either Matlab’s SVM or LIBSVM, but not both at the same time. To select which SVM implementation is used, set the Matlab search path so that either LIBSVM is on top (comes earlier; to use LIBSVM) or at the bottom (comes later; to use Matlab’s SVM).</p>
</section>
<section id="use-surface-based-mapping-with-a-low-resolution-output-surface">
<h3><a class="toc-backref" href="#id71" role="doc-backlink">Use surface-based mapping with a low-resolution output surface</a><a class="headerlink" href="#use-surface-based-mapping-with-a-low-resolution-output-surface" title="Link to this heading">¶</a></h3>
<p>The typical use case scenario is using <a class="reference external" href="http://freesurfer.net">FreeSurfer</a> pial and white matter surfaces that are resampled to standard topology using MapIcosahedron. Then, the high-resolution surfaces are used to define which voxels are associated with each searchlight, whereas the low-resolution surface is used as centers for the searchlight. The former aims to result in more precise selection of voxels; the latter in fewer centers, and thus reduced execution time for the searchlight.</p>
<p>In this scenario, it is required that the vertices in low-resolution surface are a subset of the pair-wise averages of vertices in the high-resolution pial and white surfaces. A typical use case is using standard topologies from AFNI’s MapIcosahedron, where the high resolution surfaces are constructed using X linear divisionsof the triangles of an icosahedron, the low-resolution surface is constructed with Y linear divisions, and Y&lt;X and X is an integer multiple of Y.</p>
<p>The <a class="reference external" href="https://github.com/PyMVPA/PyMVPA/blob/master/bin/pymvpa2-prep-afni-surf">pymvpa2-prep-afni-surf</a> script (part of <a class="reference external" href="http://pymvpa.org">PyMVPA</a>, which is required to run it) provides exactly this functionality. It will resample the surfaces to various resolutions, ranging from 4 linear divisions (162 nodes per hemisphere) to 128 linear divisions (163842 nodes per hemisphere) in steps of powers of two. It will also generate intermediate surfaces (pair-wise avarages of the nodes of the pial and white matter surfaes), and merge left (<code class="docutils literal notranslate"><span class="pre">lh</span></code>) and right (<code class="docutils literal notranslate"><span class="pre">rh</span></code>) hemisphere into a single hemisphere (<code class="docutils literal notranslate"><span class="pre">mh</span></code>). The merged surfaces have the advantages that the searchlight has to be run only once to get results for both hemispheres.</p>
</section>
<section id="correct-for-multiple-comparisons">
<h3><a class="toc-backref" href="#id72" role="doc-backlink">Correct for multiple comparisons</a><a class="headerlink" href="#correct-for-multiple-comparisons" title="Link to this heading">¶</a></h3>
<p>For second level (group analysis), <a class="reference internal" href="matlab/cosmo_montecarlo_cluster_stat.html#cosmo-montecarlo-cluster-stat"><span class="std std-ref">cosmo montecarlo cluster stat</span></a> provides cluster-based correction.</p>
<p>There are three <em>components</em> in this, and they can be crossed arbitrarily:</p>
<blockquote>
<div><ol class="arabic">
<li><dl class="simple">
<dt>clustering method: either ???standard??? fixed-uncorrected thresholding, or using Threshold-Free Cluster Enhancement (TFCE). The latter is the default in CoSMoMVPA, as it has been proposed it has several advantages (Nichols &amp; Smith, 2009, Neuroimage), including:</dt><dd><ul class="simple">
<li><p>“TFCE gives generally better sensitivity than other methods over a wide range of test signal shapes and SNR values”.</p></li>
<li><p>avoids “the need to define the initial cluster-forming threshold (e.g., threshold the raw t-statistic image at t&gt;2.5)”.</p></li>
<li><p>avoids the issue that “initial hard thresholding introduces instability in the overall processing chain; small variations in the data around the threshold level can have a large effect on the final output.”</p></li>
<li><p>deals properly with different smoothing levels of the data.</p></li>
<li><p>makes it easier to “directly interpret the meaning of (what may ideally be) separable sub-clusters or local maxima within very extended clusters”.</p></li>
<li><p>is less affected by nonstationarity.</p></li>
</ul>
</dd>
</dl>
</li>
<li><p>support for any type of modality that CoSMoMVPA supports, including:</p>
<blockquote>
<div><ul class="simple">
<li><p>fMRI volumetric, e.g. voxel, or voxel x time</p></li>
<li><p>fMRI surface-based, e.g. node, or node x time</p></li>
<li><p>MEEG time x channel (both in sensor and source space)</p></li>
<li><p>MEEG time x channel x frequency (both in sensor and source space)</p></li>
</ul>
<p>In the case of multiple dimensions (such as time x channel x frequency) it is possible to cluster only over a subset of the dimensions. For example, a time x channel x frequency dataset can be clustered over all dimensions, or clustered over channel x frequency (which allows for more precise temporal inferences), or over channel x time (for more precise frequency inferences).</p>
</div></blockquote>
</li>
<li><p>support for either standard permutation test, or the method by Stelzer et al. (2012). To use the Stelzer approach, the user has to generate null datasets themselves. <a class="reference internal" href="matlab/cosmo_randomize_targets.html#cosmo-randomize-targets"><span class="std std-ref">cosmo randomize targets</span></a> can be used for this, but requires using a for-loop to generate multiple null datasets.</p></li>
</ol>
</div></blockquote>
<p>Because components 1-3 can be crossed arbitrarily, it allows for multiple comparison correction for a wide variety of applications.</p>
<dl class="simple">
<dt>Notes:</dt><dd><ul class="simple">
<li><p>There is no function for within-subject significance testing; through cosmo_randomize_targets and a <code class="docutils literal notranslate"><span class="pre">for</span></code>-loop the user can do that themselves.</p></li>
<li><p>There is also univariate cosmo_stat for one-sample and two-sample t-tests, and one-way and repeated measures ANOVA.</p></li>
</ul>
</dd>
</dl>
</section>
<section id="do-cross-modal-decoding-across-three-modalities">
<h3><a class="toc-backref" href="#id73" role="doc-backlink">Do cross-modal decoding across three modalities</a><a class="headerlink" href="#do-cross-modal-decoding-across-three-modalities" title="Link to this heading">¶</a></h3>
<p>‘I have a dataset with three modalities (visual, auditory, tactile) and would like to do both within-modality and cross-modality decoding. How should I proceed?’</p>
<p><a class="reference internal" href="matlab/cosmo_nchoosek_partitioner.html#cosmo-nchoosek-partitioner"><span class="std std-ref">cosmo nchoosek partitioner</span></a> can deal with two modalities quite easily, but three or more is not directly supported. Instead you can slice the dataset multiple times to select the samples of interest, as in this example:</p>
<blockquote>
<div><div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="c">% generate synthetic example data with 3 modalities, 8 chunks</span>
<span class="n">n_modalities</span><span class="p">=</span><span class="mi">3</span><span class="p">;</span>
<span class="n">ds</span><span class="p">=</span><span class="n">cosmo_synthetic_dataset</span><span class="p">(</span><span class="s">&#39;nchunks&#39;</span><span class="p">,</span><span class="n">n_modalities</span><span class="o">*</span><span class="mi">8</span><span class="p">,</span><span class="s">&#39;sigma&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="n">ds</span><span class="p">.</span><span class="n">sa</span><span class="p">.</span><span class="n">modality</span><span class="p">=</span><span class="nb">mod</span><span class="p">(</span><span class="n">ds</span><span class="p">.</span><span class="n">sa</span><span class="p">.</span><span class="n">chunks</span><span class="p">,</span><span class="n">n_modalities</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c">% in range 1:n_modalities</span>
<span class="n">ds</span><span class="p">.</span><span class="n">sa</span><span class="p">.</span><span class="n">chunks</span><span class="p">=</span><span class="nb">ceil</span><span class="p">(</span><span class="n">ds</span><span class="p">.</span><span class="n">sa</span><span class="p">.</span><span class="n">chunks</span><span class="o">/</span><span class="n">n_modalities</span><span class="p">);</span><span class="w">    </span><span class="c">% 8 chunks</span>

<span class="c">% allocate space for output</span>
<span class="n">accuracies</span><span class="p">=</span><span class="nb">NaN</span><span class="p">(</span><span class="n">n_modalities</span><span class="p">);</span>

<span class="c">% do all combinations for training and test modalities</span>
<span class="k">for</span><span class="w"> </span><span class="n">train_modality</span><span class="p">=</span><span class="mi">1</span><span class="p">:</span><span class="n">n_modalities</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">test_modality</span><span class="p">=</span><span class="mi">1</span><span class="p">:</span><span class="n">n_modalities</span>

<span class="w">        </span><span class="c">% select data in train and test modality</span>
<span class="w">        </span><span class="n">msk</span><span class="p">=</span><span class="n">cosmo_match</span><span class="p">(</span><span class="n">ds</span><span class="p">.</span><span class="n">sa</span><span class="p">.</span><span class="n">modality</span><span class="p">,[</span><span class="n">train_modality</span><span class="w"> </span><span class="n">test_modality</span><span class="p">]);</span>
<span class="w">        </span><span class="n">ds_sel</span><span class="p">=</span><span class="n">cosmo_slice</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span><span class="n">msk</span><span class="p">);</span>


<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">train_modality</span><span class="o">==</span><span class="n">test_modality</span>
<span class="w">            </span><span class="c">% within-modality cross-validation</span>
<span class="w">            </span><span class="n">partitions</span><span class="p">=</span><span class="n">cosmo_nchoosek_partitioner</span><span class="p">(</span><span class="n">ds_sel</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">            </span><span class="c">% cross-modality cross-validation</span>
<span class="w">            </span><span class="n">partitions</span><span class="p">=</span><span class="n">cosmo_nchoosek_partitioner</span><span class="p">(</span><span class="n">ds_sel</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="k">...</span>
<span class="w">                            </span><span class="s">&#39;modality&#39;</span><span class="p">,</span><span class="n">test_modality</span><span class="p">);</span>
<span class="w">        </span><span class="k">end</span>

<span class="w">        </span><span class="n">opt</span><span class="p">=</span><span class="nb">struct</span><span class="p">();</span>
<span class="w">        </span><span class="n">opt</span><span class="p">.</span><span class="n">partitions</span><span class="p">=</span><span class="n">partitions</span><span class="p">;</span>
<span class="w">        </span><span class="n">opt</span><span class="p">.</span><span class="n">classifier</span><span class="p">=@</span><span class="n">cosmo_classify_lda</span><span class="p">;</span>

<span class="w">        </span><span class="n">measure</span><span class="p">=@</span><span class="n">cosmo_crossvalidation_measure</span><span class="p">;</span>

<span class="w">        </span><span class="c">% Run the measure.</span>
<span class="w">        </span><span class="c">%</span>
<span class="w">        </span><span class="c">% (alternatively a searchlight can be used, through</span>
<span class="w">        </span><span class="c">%</span>
<span class="w">        </span><span class="c">%   ds_searchlight_result=cosmo_searchlight(ds,nh,measure,opt);</span>
<span class="w">        </span><span class="c">%</span>
<span class="w">        </span><span class="c">% where nh is a neighborhood)</span>
<span class="w">        </span><span class="n">ds_result</span><span class="p">=</span><span class="n">measure</span><span class="p">(</span><span class="n">ds_sel</span><span class="p">,</span><span class="n">opt</span><span class="p">);</span>
<span class="w">        </span><span class="n">accuracies</span><span class="p">(</span><span class="n">train_modality</span><span class="p">,</span><span class="n">test_modality</span><span class="p">)=</span><span class="n">ds_result</span><span class="p">.</span><span class="n">samples</span><span class="p">;</span>
<span class="w">    </span><span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
</div></blockquote>
</section>
<section id="compute-classification-accuracies-manually">
<h3><a class="toc-backref" href="#id74" role="doc-backlink">Compute classification accuracies manually</a><a class="headerlink" href="#compute-classification-accuracies-manually" title="Link to this heading">¶</a></h3>
<p>‘I computed predictions using <a class="reference internal" href="matlab/cosmo_crossvalidation_measure.html#cosmo-crossvalidation-measure"><span class="std std-ref">cosmo crossvalidation measure</span></a> with the <code class="docutils literal notranslate"><span class="pre">output</span></code> option set to <code class="docutils literal notranslate"><span class="pre">'predictions'</span></code>, but now I would like to compute the classification accuracies afterwards. How can I do that?’</p>
<p>If <code class="docutils literal notranslate"><span class="pre">pred_ds</span></code> is the dataset with predictions, then accuracies can be computed by:</p>
<blockquote>
<div><div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">acc_ds</span><span class="p">=</span><span class="n">cosmo_slice</span><span class="p">(</span><span class="n">pred_ds</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span><span class="w">  </span><span class="c">% take single slice</span>
<span class="n">acc_ds</span><span class="p">.</span><span class="n">sa</span><span class="p">=</span><span class="nb">struct</span><span class="p">();</span><span class="w">             </span><span class="c">% reset sample attributes</span>
<span class="n">acc_ds</span><span class="p">.</span><span class="n">samples</span><span class="p">=</span><span class="n">nanmean</span><span class="p">(</span><span class="nb">bsxfun</span><span class="p">(@</span><span class="nb">eq</span><span class="p">,</span><span class="n">pred_ds</span><span class="p">.</span><span class="n">samples</span><span class="p">,</span><span class="n">pred_ds</span><span class="p">.</span><span class="n">sa</span><span class="p">.</span><span class="n">targets</span><span class="p">));</span>
</pre></div>
</div>
</div></blockquote>
</section>
<section id="make-a-merged-hemisphere-from-a-left-and-right-hemisphere">
<h3><a class="toc-backref" href="#id75" role="doc-backlink">Make a merged hemisphere from a left and right hemisphere</a><a class="headerlink" href="#make-a-merged-hemisphere-from-a-left-and-right-hemisphere" title="Link to this heading">¶</a></h3>
<p>‘Using Freesurfer I generated left and right hemisphere anatomical surface files. How can I combine them into a merged hemisphere?’</p>
<p>You could use the function below.</p>
<blockquote>
<div><div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="k">function</span><span class="w"> </span><span class="nf">[v_merged, f_merged] = merge_surfaces</span><span class="p">(</span>filenames<span class="p">)</span>
<span class="c">% merge surface filesep</span>
<span class="c">%</span>
<span class="c">% Input:</span>
<span class="c">%   filenames:      cell filenames of surfaces to merge, for example</span>
<span class="c">%                   these can be &#39;.asc&#39;  files as generated by FreeSurfer&#39;s</span>
<span class="c">%                   recon_all</span>
<span class="c">%</span>
<span class="c">% Output:</span>
<span class="c">%   v_merged        Nx3 matrix with vertex coordinates for N vertices</span>
<span class="c">%   f_merged        Mx3 matrix with face indices for M faces</span>
<span class="c">%</span>
<span class="c">% Example:</span>
<span class="c">%   % merge left and right hemispheres of pial surface</span>
<span class="c">%   fns = {&#39;lh.pial.asc&#39;, &#39;rh.pial.asc&#39;}</span>
<span class="c">%   [v,f]=merge_surfaces(fns)</span>
<span class="c">%   surfing_write(&#39;mh.pial.asc&#39;,v,f);</span>
<span class="c">%</span>
<span class="c">% Note:</span>
<span class="c">% - this function uses surfing_read from the Surfing toolbox.</span>
<span class="c">%   See https://github.com/surfing/surfing</span>
<span class="c">% - the output can be saved with surfing_write</span>
<span class="c">%</span>
<span class="c">% Nick Oosterhof 2018-10-12</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="o">~</span><span class="nb">iscellstr</span><span class="p">(</span><span class="n">filenames</span><span class="p">)</span>
<span class="w">        </span><span class="nb">error</span><span class="p">(</span><span class="s">&#39;input must be cell with filenames&#39;</span><span class="p">)</span>
<span class="w">    </span><span class="k">end</span>

<span class="w">    </span><span class="n">n_surfaces</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">numel</span><span class="p">(</span><span class="n">filenames</span><span class="p">);</span>
<span class="w">    </span><span class="n">v_s</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">cell</span><span class="p">(</span><span class="n">n_surfaces</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="n">f_s</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">cell</span><span class="p">(</span><span class="n">n_surfaces</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>

<span class="w">    </span><span class="n">n_total</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">k</span><span class="p">=</span><span class="mi">1</span><span class="p">:</span><span class="n">n_surfaces</span>
<span class="w">        </span><span class="n">filename</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">filenames</span><span class="p">{</span><span class="n">k</span><span class="p">};</span>
<span class="w">        </span><span class="p">[</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">surfing_read</span><span class="p">(</span><span class="n">filename</span><span class="p">);</span>
<span class="w">        </span><span class="n">cosmo_disp</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="w">        </span><span class="n">cosmo_disp</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

<span class="w">        </span><span class="c">% keep the vertex coordinates</span>
<span class="w">        </span><span class="n">v_s</span><span class="p">{</span><span class="n">k</span><span class="p">}</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">v</span><span class="p">;</span>

<span class="w">        </span><span class="c">% update face indices to take into account previous input surfaces</span>
<span class="w">        </span><span class="n">f_s</span><span class="p">{</span><span class="n">k</span><span class="p">}</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">n_total</span><span class="p">;</span>

<span class="w">        </span>#<span class="w"> </span><span class="nb">update</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">first</span><span class="w"> </span><span class="n">face</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">next</span><span class="w"> </span><span class="nb">surface</span>
<span class="w">        </span><span class="n">n_vertices</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">size</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="w">        </span><span class="n">n_total</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">n_total</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">n_vertices</span><span class="p">;</span>
<span class="w">    </span><span class="k">end</span>

<span class="w">    </span><span class="n">v_merged</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">cat</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">v_s</span><span class="p">{:});</span>
<span class="w">    </span><span class="n">f_merged</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">cat</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">f_s</span><span class="p">{:});</span>
</pre></div>
</div>
</div></blockquote>
<p>Note: this question is about anatomical information (positions of nodes on the surface and node indices that form triangles on the surface); the question below is about functional, statistical or other data for maps on the surface. They share the approach in incrementing node indices for all but the first surface.</p>
</section>
<section id="merge-surface-data-from-two-hemispheres">
<h3><a class="toc-backref" href="#id76" role="doc-backlink">Merge surface data from two hemispheres</a><a class="headerlink" href="#merge-surface-data-from-two-hemispheres" title="Link to this heading">¶</a></h3>
<p>‘I have surface-based data from two hemispheres. How can I combine these into a single surface dataset structure?’</p>
<p>In the following example, <code class="docutils literal notranslate"><span class="pre">ds_left</span></code> and <code class="docutils literal notranslate"><span class="pre">ds_right</span></code> are two dataset structs (for example, obtained through <a class="reference internal" href="matlab/cosmo_surface_dataset.html#cosmo-surface-dataset"><span class="std std-ref">cosmo surface dataset</span></a>) from the left and right hemisphere. They can be combined into a single dataset as follows:</p>
<blockquote>
<div><div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="c">% generate synthetic left and right hemisphere data</span>
<span class="c">% (this is just example data for illustration)</span>
<span class="n">ds_left</span><span class="p">=</span><span class="n">cosmo_synthetic_dataset</span><span class="p">(</span><span class="s">&#39;type&#39;</span><span class="p">,</span><span class="s">&#39;surface&#39;</span><span class="p">,</span><span class="s">&#39;seed&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="n">ds_right</span><span class="p">=</span><span class="n">cosmo_synthetic_dataset</span><span class="p">(</span><span class="s">&#39;type&#39;</span><span class="p">,</span><span class="s">&#39;surface&#39;</span><span class="p">,</span><span class="s">&#39;seed&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>

<span class="c">% Set the number of vertices of the left surface.</span>
<span class="c">% If the surface is sparse (it does not have data for all nodes), it *may*</span>
<span class="c">% be necessary to adjust this value manually. In that case, consider to:</span>
<span class="c">%</span>
<span class="c">%  - compute the number of vertices, if it is a standardized surface from</span>
<span class="c">%    MapIcosahedron. If the ld parameter was set to 64, then the number of</span>
<span class="c">%    vertices is 10*64^2+2=40962.</span>
<span class="c">%  - get the number of vertices using:</span>
<span class="c">%       [v,f]=surfing_read(&#39;left_surface.asc&#39;);</span>
<span class="c">%       nverts=max(size(v));</span>
<span class="c">%</span>
<span class="p">[</span><span class="n">unused</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="p">]=</span><span class="n">cosmo_dim_find</span><span class="p">(</span><span class="n">ds_left</span><span class="p">,</span><span class="w"> </span><span class="s">&#39;node_indices&#39;</span><span class="p">);</span>
<span class="n">nverts_left</span><span class="p">=</span><span class="nb">max</span><span class="p">(</span><span class="n">ds_left</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">fdim</span><span class="p">.</span><span class="n">values</span><span class="p">{</span><span class="n">index</span><span class="p">});</span>

<span class="c">% get the offset to set the feature attribute index later</span>
<span class="n">offset_left</span><span class="p">=</span><span class="nb">numel</span><span class="p">(</span><span class="n">ds_left</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">fdim</span><span class="p">.</span><span class="n">values</span><span class="p">{</span><span class="n">index</span><span class="p">});</span>

<span class="c">% update node indices to support indexing data from two hemispheres</span>
<span class="n">node_indices</span><span class="p">=[</span><span class="n">ds_left</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">fdim</span><span class="p">.</span><span class="n">values</span><span class="p">{</span><span class="n">index</span><span class="p">},</span><span class="w"> </span><span class="k">...</span>
<span class="w">                </span><span class="n">nverts_left</span><span class="o">+</span><span class="n">ds_right</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">fdim</span><span class="p">.</span><span class="n">values</span><span class="p">{</span><span class="n">index</span><span class="p">}];</span>
<span class="n">ds_left</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">fdim</span><span class="p">.</span><span class="n">values</span><span class="p">{</span><span class="n">index</span><span class="p">}=</span><span class="n">node_indices</span><span class="p">;</span>
<span class="n">ds_right</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">fdim</span><span class="p">.</span><span class="n">values</span><span class="p">{</span><span class="n">index</span><span class="p">}=</span><span class="n">node_indices</span><span class="p">;</span>

<span class="c">% update node indices for right hemisphere</span>
<span class="nb">assert</span><span class="p">(</span><span class="nb">all</span><span class="p">(</span><span class="n">ds_left</span><span class="p">.</span><span class="n">fa</span><span class="p">.</span><span class="n">node_indices</span><span class="o">&lt;=</span><span class="n">offset_left</span><span class="p">));</span><span class="w"> </span><span class="c">% safety check</span>
<span class="n">ds_right</span><span class="p">.</span><span class="n">fa</span><span class="p">.</span><span class="n">node_indices</span><span class="p">=</span><span class="n">ds_right</span><span class="p">.</span><span class="n">fa</span><span class="p">.</span><span class="n">node_indices</span><span class="o">+</span><span class="n">offset_left</span><span class="p">;</span>

<span class="c">% merge hemisphes</span>
<span class="n">ds_left_right</span><span class="p">=</span><span class="n">cosmo_stack</span><span class="p">({</span><span class="n">ds_left</span><span class="p">,</span><span class="n">ds_right</span><span class="p">},</span><span class="mi">2</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>The resulting dataset <code class="docutils literal notranslate"><span class="pre">ds_left_right</span></code> can be stored in a file using <a class="reference internal" href="matlab/cosmo_map2surface.html#cosmo-map2surface"><span class="std std-ref">cosmo map2surface</span></a>.</p>
</section>
<section id="visualize-and-store-multiple-fmri-volumes">
<h3><a class="toc-backref" href="#id77" role="doc-backlink">Visualize and store multiple fMRI volumes</a><a class="headerlink" href="#visualize-and-store-multiple-fmri-volumes" title="Link to this heading">¶</a></h3>
<p>‘I have an fMRI volumetric dataset with three volumes. <a class="reference internal" href="matlab/cosmo_plot_slices.html#cosmo-plot-slices"><span class="std std-ref">cosmo plot slices</span></a> gives an error when trying to visualize this dataset. How can I visualize the volumes and store them as NIFTI files?’</p>
<p>In this example, <code class="docutils literal notranslate"><span class="pre">ds</span></code> is a dataset structure with three volumes. To visualize and store the third volume, do:</p>
<blockquote>
<div><div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">ds3</span><span class="p">=</span><span class="n">cosmo_slice</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span><span class="w">              </span><span class="c">% select third sample (volume)</span>

<span class="n">cosmo_plot_slices</span><span class="p">(</span><span class="n">ds3</span><span class="p">);</span><span class="w">             </span><span class="c">% visualization in CoSMoMVPA</span>

<span class="n">cosmo_map2fmri</span><span class="p">(</span><span class="n">ds3</span><span class="p">,</span><span class="s">&#39;volume3.nii&#39;</span><span class="p">);</span><span class="w">  </span><span class="c">% for visualization in</span>
<span class="w">                                    </span><span class="c">% other programs</span>
</pre></div>
</div>
</div></blockquote>
<p>Note that several fMRI visualization packages can also visualize fMRI datasets with multiple volumes. To store all volumes in a single NIFTI file, simply do:</p>
<blockquote>
<div><div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">cosmo_map2fmri</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span><span class="s">&#39;all_volumes.nii&#39;</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>For example, <a class="reference external" href="http://www.nitrc.org/projects/mricron">MRIcron</a> can be used to visualize each of the volumes in the resulting NIFTI file.</p>
</section>
<section id="average-along-features-in-a-neighborhood">
<h3><a class="toc-backref" href="#id78" role="doc-backlink">Average along features in a neighborhood</a><a class="headerlink" href="#average-along-features-in-a-neighborhood" title="Link to this heading">¶</a></h3>
<p>‘I have defined a <a class="reference internal" href="cosmomvpa_concepts.html#cosmomvpa-neighborhood"><span class="std std-ref">neighborhood</span></a> for my dataset, and now I would like to compute the average across features at each searchlight location. How can I do that?’</p>
<p>To average along features, you can define a new measure:</p>
<blockquote>
<div><div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="k">function</span><span class="w"> </span>ds_mean<span class="p">=</span><span class="nf">my_averaging_measure</span><span class="p">(</span>ds<span class="p">)</span>
<span class="c">% compute the average along features, and copies .sa</span>
<span class="c">% and .a.sdim, if present</span>

<span class="w">    </span><span class="n">ds_mean</span><span class="p">=</span><span class="nb">struct</span><span class="p">();</span>
<span class="w">    </span><span class="n">ds_mean</span><span class="p">.</span><span class="n">samples</span><span class="p">=</span><span class="nb">mean</span><span class="p">(</span><span class="n">ds</span><span class="p">.</span><span class="n">samples</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">cosmo_isfield</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span><span class="s">&#39;sa&#39;</span><span class="p">)</span>
<span class="w">        </span><span class="n">ds_mean</span><span class="p">.</span><span class="n">sa</span><span class="p">=</span><span class="n">ds</span><span class="p">.</span><span class="n">sa</span><span class="p">;</span>
<span class="w">    </span><span class="k">end</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">cosmo_isfield</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span><span class="s">&#39;a.sdim&#39;</span><span class="p">)</span>
<span class="w">        </span><span class="n">ds_mean</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">sdim</span><span class="p">=</span><span class="n">ds</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">sdim</span><span class="p">;</span>
<span class="w">    </span><span class="k">end</span>
</pre></div>
</div>
</div></blockquote>
<p>This measure can then be used directly with <a class="reference internal" href="matlab/cosmo_searchlight.html#cosmo-searchlight"><span class="std std-ref">cosmo searchlight</span></a>. Note that the output has the same number of samples as the input dataset (i.e., <code class="docutils literal notranslate"><span class="pre">.samples</span></code> has the same number of rows); depending on how the neighborhood is defined, the number of features in the output dataset may either be the same as or different from the input dataset.</p>
<p>It is also possible to define such a measure <em>inline</em>; for example, if the input dataset has <code class="docutils literal notranslate"><span class="pre">.sa</span></code> but not <code class="docutils literal notranslate"><span class="pre">.a.sdim</span></code> (this is the most common case; but exceptions are outputs from <a class="reference internal" href="matlab/cosmo_dim_generalization_measure.html#cosmo-dim-generalization-measure"><span class="std std-ref">cosmo dim generalization measure</span></a> and <a class="reference internal" href="matlab/cosmo_dissimilarity_matrix_measure.html#cosmo-dissimilarity-matrix-measure"><span class="std std-ref">cosmo dissimilarity matrix measure</span></a>), then the following computes the average across voxels at each neighborhood location:</p>
<blockquote>
<div><div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="c">% tiny dataset: 6 voxels</span>
<span class="n">ds</span><span class="p">=</span><span class="n">cosmo_synthetic_dataset</span><span class="p">();</span>

<span class="c">% tiny radius: 1 voxel</span>
<span class="n">nh</span><span class="p">=</span><span class="n">cosmo_spherical_neighborhood</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span><span class="s">&#39;radius&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>

<span class="c">% define averaging measure inline</span>
<span class="n">my_averageing_measure</span><span class="p">=@(</span><span class="n">x</span><span class="p">,</span><span class="n">opt</span><span class="p">)</span><span class="w"> </span><span class="n">cosmo_structjoin</span><span class="p">(</span><span class="k">...</span>
<span class="w">                                    </span><span class="s">&#39;samples&#39;</span><span class="p">,</span><span class="nb">mean</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">samples</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="k">...</span>
<span class="w">                                    </span><span class="s">&#39;sa&#39;</span><span class="p">,</span><span class="n">x</span><span class="p">.</span><span class="n">sa</span><span class="p">);</span>

<span class="c">% compute average in each neighborhood location across features (voxels)</span>
<span class="n">ds_mean</span><span class="p">=</span><span class="n">cosmo_searchlight</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span><span class="n">nh</span><span class="p">,</span><span class="n">my_averageing_measure</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>The line approach may be a bit slower than defining a separate function, but the speed difference is usually not substantial.</p>
</section>
<section id="select-a-time-interval-in-an-meeg-dataset">
<h3><a class="toc-backref" href="#id79" role="doc-backlink">Select a time interval in an MEEG dataset</a><a class="headerlink" href="#select-a-time-interval-in-an-meeg-dataset" title="Link to this heading">¶</a></h3>
<p>To select only a particular time range, consider the following:</p>
<blockquote>
<div><div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="c">% for this example, generate synthetic data</span>
<span class="n">ds</span><span class="p">=</span><span class="n">cosmo_synthetic_dataset</span><span class="p">(</span><span class="s">&#39;type&#39;</span><span class="p">,</span><span class="s">&#39;meeg&#39;</span><span class="p">,</span><span class="k">...</span>
<span class="w">                            </span><span class="s">&#39;size&#39;</span><span class="p">,</span><span class="s">&#39;huge&#39;</span><span class="p">);</span>

<span class="c">% Select time points between 50 and 300 ms</span>
<span class="n">time_selector</span><span class="p">=@(</span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="n">t</span><span class="o">&gt;=</span><span class="mf">.04999</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">t</span><span class="o">&lt;=</span><span class="mf">0.3001</span><span class="p">;</span>
<span class="n">time_msk</span><span class="p">=</span><span class="n">cosmo_dim_match</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span><span class="s">&#39;time&#39;</span><span class="p">,</span><span class="n">time_selector</span><span class="p">=@);</span>
<span class="c">%</span>
<span class="c">% (alternative to the above is</span>

<span class="c">% slice dataset</span>
<span class="n">ds_time</span><span class="p">=</span><span class="n">cosmo_slice</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span><span class="n">time_msk</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>

<span class="c">% Optionally prune the dataset</span>
<span class="c">% - without cosmo_dim_prune: the output of map2meeg(ds_time) will</span>
<span class="c">%   have all the time points of the original dataset; data for</span>
<span class="c">%   missing time points will be set to zero or NaN.</span>
<span class="c">% - with cosmo_dim_prune: the output of map2meeg(ds_time) will</span>
<span class="c">%   not contain the removed time points.</span>

<span class="n">ds_time</span><span class="p">=</span><span class="n">cosmo_dim_prune</span><span class="p">(</span><span class="n">ds_time</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>Note that in the example above, the <cite>time_selector</cite> variable is a function handle that is used to specify a time range. The minimal and maximum values of 0.04999 and 0.30001 (instead of 0.05 and 0.30) are used to address potential tiny rounding errors, as it may be the case that the time points stored in the datasets are not exact multiples of <cite>1/1000</cite>. For example, in the following expression:</p>
<blockquote>
<div><div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="p">(((</span><span class="mi">0</span><span class="p">:</span><span class="mf">.1</span><span class="p">:</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">70</span><span class="p">)</span><span class="o">*</span><span class="mi">70</span><span class="p">)</span><span class="o">-</span><span class="p">(</span><span class="mi">0</span><span class="p">:</span><span class="mf">.1</span><span class="p">:</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>one might expect a vector of only zeros because of the identities <cite>a==(a+b)-b</cite> and <cite>a==(a/b)/b</cite> (for finite, non-zero values of <cite>a</cite> and <cite>b</cite>), yet both Matlab and GNU Octave return:</p>
<blockquote>
<div><div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">and</span><span class="w"> </span><span class="p">=</span>

<span class="w">   </span><span class="mf">1.0e-15</span><span class="w"> </span><span class="o">*</span>

<span class="w">  </span><span class="n">Columns</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">through</span><span class="w"> </span><span class="mi">6</span>

<span class="w">         </span><span class="mi">0</span><span class="w">         </span><span class="mi">0</span><span class="w">         </span><span class="mi">0</span><span class="w">   </span><span class="o">-</span><span class="mf">0.0555</span><span class="w">         </span><span class="mi">0</span><span class="w">         </span><span class="mi">0</span>

<span class="w">  </span><span class="n">Columns</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="n">through</span><span class="w"> </span><span class="mi">11</span>

<span class="w">         </span><span class="mi">0</span><span class="w">    </span><span class="mf">0.1110</span><span class="w">         </span><span class="mi">0</span><span class="w">         </span><span class="mi">0</span><span class="w">         </span><span class="mi">0</span>
</pre></div>
</div>
</div></blockquote>
<p>See also: <a class="reference internal" href="matlab/cosmo_dim_match.html#cosmo-dim-match"><span class="std std-ref">cosmo dim match</span></a>, <a class="reference internal" href="matlab/cosmo_slice.html#cosmo-slice"><span class="std std-ref">cosmo slice</span></a>, <a class="reference internal" href="matlab/cosmo_dim_prune.html#cosmo-dim-prune"><span class="std std-ref">cosmo dim prune</span></a>.</p>
</section>
<section id="select-a-particular-channel-type-in-an-meeg-dataset">
<h3><a class="toc-backref" href="#id80" role="doc-backlink">Select a particular channel type in an MEEG dataset</a><a class="headerlink" href="#select-a-particular-channel-type-in-an-meeg-dataset" title="Link to this heading">¶</a></h3>
<p>To select channels of a particular type, consider the following:</p>
<blockquote>
<div><div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="c">% for this example, generate synthetic data</span>
<span class="n">ds</span><span class="p">=</span><span class="n">cosmo_synthetic_dataset</span><span class="p">(</span><span class="s">&#39;type&#39;</span><span class="p">,</span><span class="s">&#39;meeg&#39;</span><span class="p">,</span><span class="k">...</span>
<span class="w">                            </span><span class="s">&#39;size&#39;</span><span class="p">,</span><span class="s">&#39;huge&#39;</span><span class="p">);</span>

<span class="c">%%</span>
<span class="c">% select channels</span>
<span class="c">% (the output of chantypes in the command below</span>
<span class="c">%  indicates which channel types can be selected)</span>
<span class="p">[</span><span class="n">chantypes</span><span class="p">,</span><span class="n">senstypes</span><span class="p">]=</span><span class="n">cosmo_meeg_chantype</span><span class="p">(</span><span class="n">ds</span><span class="p">);</span>

<span class="c">% in this example, select MEG planar combined channel</span>
<span class="n">chan_type_of_interest</span><span class="p">=</span><span class="s">&#39;meg_planar_combined&#39;</span><span class="p">;</span>

<span class="n">chan_indices</span><span class="p">=</span><span class="nb">find</span><span class="p">(</span><span class="n">cosmo_match</span><span class="p">(</span><span class="n">chantypes</span><span class="p">,</span><span class="k">...</span>
<span class="w">                          </span><span class="n">chan_type_of_interest</span><span class="p">));</span>

<span class="c">% define channel mask</span>
<span class="n">chan_msk</span><span class="p">=</span><span class="n">cosmo_match</span><span class="p">(</span><span class="n">ds</span><span class="p">.</span><span class="n">fa</span><span class="p">.</span><span class="n">chan</span><span class="p">,</span><span class="n">chan_indices</span><span class="p">);</span>

<span class="c">% slice the dataset</span>
<span class="n">ds_chan</span><span class="p">=</span><span class="n">cosmo_slice</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span><span class="n">chan_msk</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>


<span class="c">% Optionally prune the dataset</span>
<span class="c">% - without cosmo_dim_prune: the output of map2meeg(ds_chan) will</span>
<span class="c">%   have all the channels of the original dataset; data for</span>
<span class="c">%   missing channels will be set to zero or NaN.</span>
<span class="c">% - with cosmo_dim_prune: the output of running map2meeg(ds_chan) will</span>
<span class="c">%   not contain the removed channels.</span>

<span class="n">ds_chan</span><span class="p">=</span><span class="n">cosmo_dim_prune</span><span class="p">(</span><span class="n">ds_chan</span><span class="p">);</span><span class="w"> </span><span class="c">% to really remove channels</span>
</pre></div>
</div>
</div></blockquote>
<p>See also: <a class="reference internal" href="matlab/cosmo_meeg_chantype.html#cosmo-meeg-chantype"><span class="std std-ref">cosmo meeg chantype</span></a>, <a class="reference internal" href="matlab/cosmo_slice.html#cosmo-slice"><span class="std std-ref">cosmo slice</span></a>, <a class="reference internal" href="matlab/cosmo_match.html#cosmo-match"><span class="std std-ref">cosmo match</span></a>, <a class="reference internal" href="matlab/cosmo_dim_prune.html#cosmo-dim-prune"><span class="std std-ref">cosmo dim prune</span></a>.</p>
</section>
<section id="use-only-a-subset-of-channels-for-my-analysis">
<h3><a class="toc-backref" href="#id81" role="doc-backlink">Use only a subset of channels for my analysis?</a><a class="headerlink" href="#use-only-a-subset-of-channels-for-my-analysis" title="Link to this heading">¶</a></h3>
<p>‘I have time-frequency MEEG data for all channels in the layout. How can I select data from a region of interest, in other words use only a subset? Also, how can I compute the response averaged over the selected channels?’</p>
<p>First, in order to select a subset of channels of interest, consider the following:</p>
<blockquote>
<div><div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="c">% generate some example data</span>
<span class="n">ds</span><span class="p">=</span><span class="n">cosmo_synthetic_dataset</span><span class="p">(</span><span class="s">&#39;size&#39;</span><span class="p">,</span><span class="s">&#39;huge&#39;</span><span class="p">,</span><span class="s">&#39;type&#39;</span><span class="p">,</span><span class="s">&#39;timefreq&#39;</span><span class="p">,</span><span class="k">...</span>
<span class="w">                        </span><span class="s">&#39;ntargets&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="s">&#39;nchunks&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>

<span class="c">% define channels of interest</span>
<span class="n">channels_of_interest</span><span class="p">={</span><span class="s">&#39;MEG0941&#39;</span><span class="p">,</span><span class="s">&#39;MEG0942&#39;</span><span class="p">,</span><span class="k">...</span>
<span class="w">                      </span><span class="s">&#39;MEG1831&#39;</span><span class="p">,</span><span class="s">&#39;MEG1832&#39;</span><span class="p">,</span><span class="k">...</span>
<span class="w">                      </span><span class="p">};</span>

<span class="c">% define mask</span>
<span class="n">msk</span><span class="p">=</span><span class="n">cosmo_dim_match</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span><span class="s">&#39;chan&#39;</span><span class="p">,</span><span class="w"> </span><span class="n">channels_of_interest</span><span class="p">);</span>

<span class="nb">fprintf</span><span class="p">(</span><span class="s">&#39;Selecting %.1f%% of the channels\n&#39;</span><span class="p">,</span><span class="mi">100</span><span class="o">*</span><span class="nb">mean</span><span class="p">(</span><span class="n">msk</span><span class="p">));</span>

<span class="c">% select data</span>
<span class="n">ds</span><span class="p">=</span><span class="n">cosmo_slice</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span><span class="n">msk</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>

<span class="c">% prune dataset</span>
<span class="n">ds</span><span class="p">=</span><span class="n">cosmo_dim_prune</span><span class="p">(</span><span class="n">ds</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>Then, to compute the average for each time point and frequency bin:</p>
<blockquote>
<div><div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="c">% average for each time point and frequency bin separately</span>
<span class="n">other_dims</span><span class="p">={</span><span class="s">&#39;time&#39;</span><span class="p">,</span><span class="s">&#39;freq&#39;</span><span class="p">};</span>
<span class="n">feature_averager</span><span class="p">=@(</span><span class="n">x</span><span class="p">)</span><span class="nb">mean</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
<span class="n">ds_avg</span><span class="p">=</span><span class="n">cosmo_fx</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span><span class="n">feature_averager</span><span class="p">,</span><span class="n">other_dims</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>

<span class="c">% remove the channel dimension</span>
<span class="n">ds_avg</span><span class="p">=</span><span class="n">cosmo_dim_remove</span><span class="p">(</span><span class="n">ds_avg</span><span class="p">,</span><span class="s">&#39;chan&#39;</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>In this case the data is in time-frequency space. If there is only one sample (i.e. .samples is a row vector), it can be visualized as a time by frequency matrix:</p>
<blockquote>
<div><div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="c">% safety check</span>
<span class="nb">assert</span><span class="p">(</span><span class="nb">size</span><span class="p">(</span><span class="n">ds_avg</span><span class="p">.</span><span class="n">samples</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">,</span><span class="s">&#39;only a single sample is supported&#39;</span><span class="p">);</span>

<span class="c">% unflatten</span>
<span class="p">[</span><span class="n">data</span><span class="p">,</span><span class="n">labels</span><span class="p">,</span><span class="nb">values</span><span class="p">]=</span><span class="n">cosmo_unflatten</span><span class="p">(</span><span class="n">ds_avg</span><span class="p">);</span>
<span class="nb">assert</span><span class="p">(</span><span class="nb">isequal</span><span class="p">(</span><span class="n">labels</span><span class="p">,{</span><span class="s">&#39;freq&#39;</span><span class="p">;</span><span class="s">&#39;time&#39;</span><span class="p">}));</span><span class="w"> </span><span class="c">% safety check</span>

<span class="c">% make it a matrix</span>
<span class="n">freq_time</span><span class="p">=</span><span class="nb">squeeze</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>

<span class="c">% visualize data</span>
<span class="n">label_step</span><span class="p">=</span><span class="mi">5</span><span class="p">;</span>
<span class="n">freq_values</span><span class="p">=</span><span class="nb">values</span><span class="p">{</span><span class="mi">1</span><span class="p">};</span>
<span class="n">n_freq</span><span class="p">=</span><span class="nb">numel</span><span class="p">(</span><span class="n">freq_values</span><span class="p">);</span>
<span class="n">keep_freq</span><span class="p">=</span><span class="mi">1</span><span class="p">:</span><span class="n">label_step</span><span class="p">:</span><span class="n">n_freq</span><span class="p">;</span>

<span class="n">time_values</span><span class="p">=</span><span class="nb">values</span><span class="p">{</span><span class="mi">2</span><span class="p">};</span>
<span class="n">n_time</span><span class="p">=</span><span class="nb">numel</span><span class="p">(</span><span class="n">time_values</span><span class="p">);</span>
<span class="n">keep_time</span><span class="p">=</span><span class="mi">1</span><span class="p">:</span><span class="n">label_step</span><span class="p">:</span><span class="n">n_time</span><span class="p">;</span>

<span class="nb">imagesc</span><span class="p">(</span><span class="n">freq_time</span><span class="p">,[</span><span class="o">-</span><span class="mi">3</span><span class="w"> </span><span class="mi">3</span><span class="p">]);</span>
<span class="nb">colorbar</span><span class="p">();</span>
<span class="nb">set</span><span class="p">(</span><span class="nb">gca</span><span class="p">,</span><span class="s">&#39;XTickLabel&#39;</span><span class="p">,</span><span class="n">time_values</span><span class="p">(</span><span class="n">keep_time</span><span class="p">),</span><span class="s">&#39;XTick&#39;</span><span class="p">,</span><span class="n">keep_time</span><span class="p">);</span>
<span class="nb">set</span><span class="p">(</span><span class="nb">gca</span><span class="p">,</span><span class="s">&#39;YTickLabel&#39;</span><span class="p">,</span><span class="n">freq_values</span><span class="p">(</span><span class="n">keep_freq</span><span class="p">),</span><span class="s">&#39;YTick&#39;</span><span class="p">,</span><span class="n">keep_freq</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
</section>
<section id="should-i-fisher-transform-correlation-values">
<h3><a class="toc-backref" href="#id82" role="doc-backlink">Should I Fisher-transform correlation values?</a><a class="headerlink" href="#should-i-fisher-transform-correlation-values" title="Link to this heading">¶</a></h3>
<p>‘When using <a class="reference internal" href="matlab/cosmo_correlation_measure.html#cosmo-correlation-measure"><span class="std std-ref">cosmo correlation measure</span></a>, <a class="reference internal" href="matlab/cosmo_target_dsm_corr_measure.html#cosmo-target-dsm-corr-measure"><span class="std std-ref">cosmo target dsm corr measure</span></a>, or <a class="reference internal" href="matlab/cosmo_dissimilarity_matrix_measure.html#cosmo-dissimilarity-matrix-measure"><span class="std std-ref">cosmo dissimilarity matrix measure</span></a>, should I transform the data, for example using Fisher transformation (<code class="docutils literal notranslate"><span class="pre">atanh</span></code>)?’</p>
<p>Assuming you would like to do second-level (group) analysis:</p>
<ul class="simple">
<li><p><a class="reference internal" href="matlab/cosmo_correlation_measure.html#cosmo-correlation-measure"><span class="std std-ref">cosmo correlation measure</span></a>: the correlations are already Fisher transformed (the transformation can be changed and/or disabled using the <code class="docutils literal notranslate"><span class="pre">post_corr_func</span></code> option)</p></li>
<li><p><a class="reference internal" href="matlab/cosmo_target_dsm_corr_measure.html#cosmo-target-dsm-corr-measure"><span class="std std-ref">cosmo target dsm corr measure</span></a>: correlation values are not Fisher transformed. You could consider applying <code class="docutils literal notranslate"><span class="pre">atanh</span></code> to the <code class="docutils literal notranslate"><span class="pre">.samples</span></code> output</p></li>
<li><p><a class="reference internal" href="matlab/cosmo_dissimilarity_matrix_measure.html#cosmo-dissimilarity-matrix-measure"><span class="std std-ref">cosmo dissimilarity matrix measure</span></a>: the <code class="docutils literal notranslate"><span class="pre">.samples</span></code> field contains, by default, one minus the correlation, and thus its range is the interval <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">2]</span></code>. Fisher-transformation should not be used, as values greater than 1 are transformed to complex (non-real) numbers.</p></li>
</ul>
</section>
<section id="average-samples-in-a-deterministic-manner">
<h3><a class="toc-backref" href="#id83" role="doc-backlink">Average samples in a deterministic manner?</a><a class="headerlink" href="#average-samples-in-a-deterministic-manner" title="Link to this heading">¶</a></h3>
<p>‘When using <a class="reference internal" href="matlab/cosmo_average_samples.html#cosmo-average-samples"><span class="std std-ref">cosmo average samples</span></a> multiple times on the same dataset, I get different avaraged datasets. How can I get the same result every time?’</p>
<p><a class="reference internal" href="matlab/cosmo_average_samples.html#cosmo-average-samples"><span class="std std-ref">cosmo average samples</span></a>  has a <code class="docutils literal notranslate"><span class="pre">seed</span></code> option; you can use any integer for a seed. For example, if <code class="docutils literal notranslate"><span class="pre">ds</span></code> is a dataset, then</p>
<blockquote>
<div><div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">ds_avg</span><span class="p">=</span><span class="n">cosmo_average_samples</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span><span class="s">&#39;seed&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>will pseudo-deterministically select the same samples upon repeated evaluations of the expression, and thus return the same result</p>
</section>
<section id="select-only-a-subset-of-features-in-a-neighborhood">
<h3><a class="toc-backref" href="#id84" role="doc-backlink">Select only a subset of features in a neighborhood?</a><a class="headerlink" href="#select-only-a-subset-of-features-in-a-neighborhood" title="Link to this heading">¶</a></h3>
<p>‘When using <a class="reference internal" href="matlab/cosmo_spherical_neighborhood.html#cosmo-spherical-neighborhood"><span class="std std-ref">cosmo spherical neighborhood</span></a> with the <code class="docutils literal notranslate"><span class="pre">radius</span></code> option, some elements in <code class="docutils literal notranslate"><span class="pre">.neighborhood</span></code> have only a few elements. How can I exclude them from subsequent searchlight analyses?</p>
<p>Although <a class="reference internal" href="matlab/cosmo_slice.html#cosmo-slice"><span class="std std-ref">cosmo slice</span></a> does not support neighborhood structures (yet), consider the following example using tiny example datasets and neighborhoods:</p>
<blockquote>
<div><div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">min_count</span><span class="p">=</span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="c">% in most use cases this is more than 4</span>

<span class="n">ds</span><span class="p">=</span><span class="n">cosmo_synthetic_dataset</span><span class="p">();</span>
<span class="n">nh</span><span class="p">=</span><span class="n">cosmo_spherical_neighborhood</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span><span class="s">&#39;radius&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>

<span class="n">keep_msk</span><span class="p">=</span><span class="n">nh</span><span class="p">.</span><span class="n">fa</span><span class="p">.</span><span class="n">nvoxels</span><span class="o">&gt;=</span><span class="n">min_count</span><span class="p">;</span>

<span class="n">nh</span><span class="p">.</span><span class="n">fa</span><span class="p">=</span><span class="n">cosmo_slice</span><span class="p">(</span><span class="n">nh</span><span class="p">.</span><span class="n">fa</span><span class="p">,</span><span class="n">keep_msk</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="s">&#39;struct&#39;</span><span class="p">);</span>
<span class="n">nh</span><span class="p">.</span><span class="n">neighbors</span><span class="p">=</span><span class="n">cosmo_slice</span><span class="p">(</span><span class="n">nh</span><span class="p">.</span><span class="n">neighbors</span><span class="p">,</span><span class="n">keep_msk</span><span class="p">);</span>

<span class="n">cosmo_check_neighborhood</span><span class="p">(</span><span class="n">nh</span><span class="p">,</span><span class="n">ds</span><span class="p">);</span><span class="w"> </span><span class="c">% sanity check</span>
</pre></div>
</div>
</div></blockquote>
<p>Alternatively, <a class="reference internal" href="matlab/cosmo_spherical_neighborhood.html#cosmo-spherical-neighborhood"><span class="std std-ref">cosmo spherical neighborhood</span></a> (and <a class="reference internal" href="matlab/cosmo_surficial_neighborhood.html#cosmo-surficial-neighborhood"><span class="std std-ref">cosmo surficial neighborhood</span></a>) can be used with a ‘count’ argument - it keeps the number of elements across neighborhoods more constant.</p>
</section>
<section id="use-multiple-comparison-correction-for-a-time-course">
<h3><a class="toc-backref" href="#id85" role="doc-backlink">Use multiple-comparison correction for a time course?</a><a class="headerlink" href="#use-multiple-comparison-correction-for-a-time-course" title="Link to this heading">¶</a></h3>
<p>‘I have a matrix of beta values (Nsubjects x Ntimepoints) for each predictor and I want to test for each timepoint (i.e. each column) if the mean beta is significantly different from zero. I ran a t-test but I wonder if I should test for multiple comparisons as well.
What would be the best way to test for significance here?’</p>
<p>You could use multiple comparison correction using Threshold-Free Cluster Enhancement with a temporal neighborhood. Suppose your data is in the following data matrix:</p>
<blockquote>
<div><div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="c">% generate gaussian example data with no signal;</span>
<span class="n">n_subjects</span><span class="p">=</span><span class="mi">15</span><span class="p">;</span>
<span class="n">time_axis</span><span class="p">=</span><span class="o">-</span><span class="mf">.1</span><span class="p">:</span><span class="mf">.01</span><span class="p">:</span><span class="mf">.5</span><span class="p">;</span>

<span class="n">n_time</span><span class="p">=</span><span class="nb">numel</span><span class="p">(</span><span class="n">time_axis</span><span class="p">);</span>
<span class="n">data</span><span class="p">=</span><span class="nb">randn</span><span class="p">(</span><span class="n">n_subjects</span><span class="p">,</span><span class="n">n_time</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>then the first step is to put this data in a dataset structure:</p>
<blockquote>
<div><div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="c">% make a dataset</span>
<span class="n">ds</span><span class="p">=</span><span class="nb">struct</span><span class="p">();</span>
<span class="n">ds</span><span class="p">.</span><span class="n">samples</span><span class="p">=</span><span class="n">data</span><span class="p">;</span>

<span class="c">% insert time dimension</span>
<span class="n">ds</span><span class="p">=</span><span class="n">cosmo_dim_insert</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,{</span><span class="s">&#39;time&#39;</span><span class="p">},{</span><span class="n">time_axis</span><span class="p">},{</span><span class="mi">1</span><span class="p">:</span><span class="nb">numel</span><span class="p">(</span><span class="n">time_axis</span><span class="p">)});</span>
</pre></div>
</div>
</div></blockquote>
<p>You would have to decide how to form clusters, i.e. whether you want to make inferences at the individual time point level, or at the cluster-of-timepoints level. Then use <a class="reference internal" href="matlab/cosmo_montecarlo_cluster_stat.html#cosmo-montecarlo-cluster-stat"><span class="std std-ref">cosmo montecarlo cluster stat</span></a> to estimate significance.</p>
<blockquote>
<div><div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="c">% Make a temporal neighborhood for clustering</span>
<span class="c">%</span>
<span class="c">% In the following, if</span>
<span class="c">%</span>
<span class="c">%   allow_clustering_over_time=true</span>
<span class="c">% then clusters can form over multiple time points. This makes the analysis</span>
<span class="c">% more sensitive if there is a true effect in the data over multiple</span>
<span class="c">% consecutive time points. However, when allow_clustering_over_time=true</span>
<span class="c">% then one cannot make inferences about a specific time point (i.e.</span>
<span class="c">% &quot;the effect was significant at t=100ms&quot;), only about a cluster (i.e</span>
<span class="c">% &quot;the effect was significant in a cluster stretching between t=50 and</span>
<span class="c">% t=150 ms&quot;). If, on the other hand,</span>
<span class="c">%</span>
<span class="c">%   allow_clustering_over_time=false</span>
<span class="c">%</span>
<span class="c">% then inferences can be made at the individual time point level, at the</span>
<span class="c">% expensive of sensitivity of detecting any significant effect if there is</span>
<span class="c">% a true effect that spans multiple consecutive time points</span>
<span class="n">allow_clustering_over_time</span><span class="p">=</span><span class="nb">false</span><span class="p">;</span><span class="w"> </span><span class="c">% true or false</span>

<span class="c">% define the neighborhood</span>
<span class="n">nh_cl</span><span class="p">=</span><span class="n">cosmo_cluster_neighborhood</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span><span class="s">&#39;time&#39;</span><span class="p">,</span><span class="n">allow_clustering_over_time</span><span class="p">);</span>

<span class="c">% set subject information</span>
<span class="n">n_samples</span><span class="p">=</span><span class="nb">size</span><span class="p">(</span><span class="n">ds</span><span class="p">.</span><span class="n">samples</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="n">ds</span><span class="p">.</span><span class="n">sa</span><span class="p">.</span><span class="n">chunks</span><span class="p">=(</span><span class="mi">1</span><span class="p">:</span><span class="n">n_samples</span><span class="p">)</span><span class="o">&#39;</span><span class="p">;</span><span class="w">     </span><span class="c">% all subjects are independent</span>
<span class="n">ds</span><span class="p">.</span><span class="n">sa</span><span class="p">.</span><span class="n">targets</span><span class="p">=</span><span class="nb">ones</span><span class="p">(</span><span class="n">n_samples</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="c">% one-sample t-test</span>

<span class="c">% set clustering</span>
<span class="n">opt</span><span class="p">=</span><span class="nb">struct</span><span class="p">();</span>
<span class="n">opt</span><span class="p">.</span><span class="n">h0_mean</span><span class="p">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c">% expected mean against which t-test is run</span>
<span class="n">opt</span><span class="p">.</span><span class="n">niter</span><span class="p">=</span><span class="mi">10000</span><span class="p">;</span><span class="w"> </span><span class="c">% 10,000 is recommended for publication-quality analyses</span>

<span class="c">% run TFCE Monte Carlo multiple comparison correction</span>
<span class="c">% in the output map, z-scores above 1.65 (for one-tailed) or 1.96 (for</span>
<span class="c">% two-tailed) tests are significant</span>
<span class="n">ds_tfce</span><span class="p">=</span><span class="n">cosmo_montecarlo_cluster_stat</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span><span class="n">nh_cl</span><span class="p">,</span><span class="n">opt</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
</section>
<section id="classify-different-groups-of-participants-such-as-patients-versus-controls">
<h3><a class="toc-backref" href="#id86" role="doc-backlink">Classify different groups of participants (such as patients versus controls)?</a><a class="headerlink" href="#classify-different-groups-of-participants-such-as-patients-versus-controls" title="Link to this heading">¶</a></h3>
<p>‘I have participants in three groups, patients1, patients2, and controls. How can I see where in the brain people these groups can be discriminated above chance level?’</p>
<blockquote>
<div><p>To do so, consider a standard searchlight using <a class="reference internal" href="matlab/cosmo_searchlight.html#cosmo-searchlight"><span class="std std-ref">cosmo searchlight</span></a> with <cite>cosmo_crossvalidation_measure</cite>. Group membership is set in <code class="docutils literal notranslate"><span class="pre">.sa.targets</span></code>. Since all participants are assumed to be independent, values in <code class="docutils literal notranslate"><span class="pre">.sa.chunks</span></code> are all unique.</p>
<p>Correcting for multiple comparisons is more difficult. Since it is not possible to do a ‘standard’ t-test (two groups) or ANOVA F-test (three or more groups), instead generate null datasets manually by randomly permuting the <code class="docutils literal notranslate"><span class="pre">.sa.targets</span></code> labels. Then use these null datasets directly as input for <a class="reference internal" href="matlab/cosmo_montecarlo_cluster_stat.html#cosmo-montecarlo-cluster-stat"><span class="std std-ref">cosmo montecarlo cluster stat</span></a> without computing a feature statistic.</p>
<p>Consider the following example:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="c">% set number of groups and number of participants in each group</span>
<span class="n">ngroups</span><span class="p">=</span><span class="mi">3</span><span class="p">;</span>
<span class="n">nchunks</span><span class="p">=</span><span class="mi">10</span><span class="p">;</span>

<span class="c">% generate example dataset with some signal that discriminates</span>
<span class="c">% the participants</span>
<span class="n">ds</span><span class="p">=</span><span class="n">cosmo_synthetic_dataset</span><span class="p">(</span><span class="s">&#39;ntargets&#39;</span><span class="p">,</span><span class="n">ngroups</span><span class="p">,</span><span class="s">&#39;nchunks&#39;</span><span class="p">,</span><span class="n">nchunks</span><span class="p">);</span>

<span class="c">% since all participants are independent, all chunks are set to</span>
<span class="c">% unique values</span>
<span class="n">ds</span><span class="p">.</span><span class="n">sa</span><span class="p">.</span><span class="n">chunks</span><span class="p">(:)=</span><span class="mi">1</span><span class="p">:(</span><span class="n">ngroups</span><span class="o">*</span><span class="n">nchunks</span><span class="p">);</span>

<span class="c">% define partitions</span>
<span class="n">fold_count</span><span class="p">=</span><span class="mi">50</span><span class="p">;</span>
<span class="n">test_count</span><span class="p">=</span><span class="mi">1</span><span class="p">;</span>
<span class="n">partitions</span><span class="p">=</span><span class="n">cosmo_independent_samples_partitioner</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span><span class="k">...</span>
<span class="w">                        </span><span class="s">&#39;fold_count&#39;</span><span class="p">,</span><span class="n">fold_count</span><span class="p">,</span><span class="k">...</span>
<span class="w">                        </span><span class="s">&#39;test_count&#39;</span><span class="p">,</span><span class="n">test_count</span><span class="p">);</span>

<span class="c">% define neighborhood</span>
<span class="n">radius_in_voxels</span><span class="p">=</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c">% typical is 3 voxels</span>
<span class="n">nh</span><span class="p">=</span><span class="n">cosmo_spherical_neighborhood</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span><span class="s">&#39;radius&#39;</span><span class="p">,</span><span class="n">radius_in_voxels</span><span class="p">);</span>

<span class="c">% run searchlight on original data</span>
<span class="n">opt</span><span class="p">=</span><span class="nb">struct</span><span class="p">();</span>
<span class="n">opt</span><span class="p">.</span><span class="n">classifier</span><span class="p">=@</span><span class="n">cosmo_classify_lda</span><span class="p">;</span>
<span class="n">opt</span><span class="p">.</span><span class="n">partitions</span><span class="p">=</span><span class="n">partitions</span><span class="p">;</span>

<span class="n">result</span><span class="p">=</span><span class="n">cosmo_searchlight</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span><span class="n">nh</span><span class="p">,</span><span class="k">...</span>
<span class="w">                    </span><span class="p">@</span><span class="n">cosmo_crossvalidation_measure</span><span class="p">,</span><span class="n">opt</span><span class="p">);</span>

<span class="c">% generate null dataset</span>
<span class="n">niter</span><span class="p">=</span><span class="mi">100</span><span class="p">;</span><span class="w"> </span><span class="c">% at least 1000 is iterations is recommended, 10000 is better</span>
<span class="n">ds_null_cell</span><span class="p">=</span><span class="nb">cell</span><span class="p">(</span><span class="n">niter</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>

<span class="k">for</span><span class="w"> </span><span class="n">iter</span><span class="p">=</span><span class="mi">1</span><span class="p">:</span><span class="n">niter</span>
<span class="w">    </span><span class="n">ds_null</span><span class="p">=</span><span class="n">ds</span><span class="p">;</span>

<span class="w">    </span><span class="n">ds_null</span><span class="p">.</span><span class="n">sa</span><span class="p">.</span><span class="n">targets</span><span class="p">=</span><span class="n">cosmo_randomize_targets</span><span class="p">(</span><span class="n">ds_null</span><span class="p">);</span>

<span class="w">    </span><span class="c">% update partitions</span>
<span class="w">    </span><span class="n">opt</span><span class="p">.</span><span class="n">partitions</span><span class="p">=</span><span class="n">cosmo_independent_samples_partitioner</span><span class="p">(</span><span class="n">ds_null</span><span class="p">,</span><span class="k">...</span>
<span class="w">                        </span><span class="s">&#39;fold_count&#39;</span><span class="p">,</span><span class="n">fold_count</span><span class="p">,</span><span class="k">...</span>
<span class="w">                        </span><span class="s">&#39;test_count&#39;</span><span class="p">,</span><span class="n">test_count</span><span class="p">);</span>


<span class="w">    </span><span class="n">null_result</span><span class="p">=</span><span class="n">cosmo_searchlight</span><span class="p">(</span><span class="n">ds_null</span><span class="p">,</span><span class="n">nh</span><span class="p">,</span><span class="k">...</span>
<span class="w">                            </span><span class="p">@</span><span class="n">cosmo_crossvalidation_measure</span><span class="p">,</span><span class="n">opt</span><span class="p">);</span>

<span class="w">    </span><span class="n">ds_null_cell</span><span class="p">{</span><span class="n">iter</span><span class="p">}=</span><span class="n">null_result</span><span class="p">;</span>
<span class="k">end</span>
<span class="c">%%</span>

<span class="c">% Since partitions are balanced, chance level</span>
<span class="c">% is the inverse of the number of groups. For example,</span>
<span class="c">% with 4 groups, chance level is 1/4 = 0.25 = 25%.</span>
<span class="n">chance_level</span><span class="p">=</span><span class="mi">1</span><span class="o">/</span><span class="n">ngroups</span><span class="p">;</span>
<span class="n">tfce_dh</span><span class="p">=</span><span class="mf">0.01</span><span class="p">;</span><span class="w"> </span><span class="c">% should be sufficient for accuracies</span>

<span class="n">opt</span><span class="p">=</span><span class="nb">struct</span><span class="p">();</span>
<span class="n">opt</span><span class="p">.</span><span class="n">h0_mean</span><span class="p">=</span><span class="n">chance_level</span><span class="p">;</span>
<span class="n">opt</span><span class="p">.</span><span class="n">dh</span><span class="p">=</span><span class="n">tfce_dh</span><span class="p">;</span>
<span class="n">opt</span><span class="p">.</span><span class="n">feature_stat</span><span class="p">=</span><span class="s">&#39;none&#39;</span><span class="p">;</span>
<span class="n">opt</span><span class="p">.</span><span class="n">null</span><span class="p">=</span><span class="n">ds_null_cell</span><span class="p">;</span>

<span class="n">cl_nh</span><span class="p">=</span><span class="n">cosmo_cluster_neighborhood</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>

<span class="c">%% compute TFCE map with z-scores</span>
<span class="c">% z-scores above 1.65 are significant at p=0.05 one-tailed.</span>

<span class="n">tfce_map</span><span class="o">-</span><span class="n">cosmo_montecarlo_cluster_stat</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="n">cl_nh</span><span class="p">,</span><span class="n">opt</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
</section>
<section id="when-running-an-meeg-searchlight-have-the-same-channels-in-the-output-dataset-as-in-the-input-dataset">
<h3><a class="toc-backref" href="#id87" role="doc-backlink">When running an MEEG searchlight, have the same channels in the output dataset as in the input dataset?</a><a class="headerlink" href="#when-running-an-meeg-searchlight-have-the-same-channels-in-the-output-dataset-as-in-the-input-dataset" title="Link to this heading">¶</a></h3>
<p>‘When I run an MEEG searchlight over channels, the searchlight dataset map has more channels than the input dataset. Is this normal?’</p>
<p>This is quite possible because the <a class="reference internal" href="matlab/cosmo_meeg_chan_neighborhood.html#cosmo-meeg-chan-neighborhood"><span class="std std-ref">cosmo meeg chan neighborhood</span></a> uses, by default, the layout that best fits the dataset. The output from the searchlight has then all channels from this layout, rather than only the channels from the input dataset. This is done so that in individual participants different channels can be removed in the preprocessing step, while group analysis on the output maps can be done on maps that have the same channels for all participants.</p>
<p>If you want to use only the channels from the input dataset (say <code class="docutils literal notranslate"><span class="pre">ds</span></code>) you can set the <code class="docutils literal notranslate"><span class="pre">label</span></code> option to ‘dataset’. See the following example, where <code class="docutils literal notranslate"><span class="pre">chan_nh</span></code> has only channels from the input dataset.</p>
<blockquote>
<div><div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">chan_nh</span><span class="p">=</span><span class="n">cosmo_meeg_chan_neighborhood</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span><span class="s">&#39;count&#39;</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="s">&#39;label&#39;</span><span class="p">,</span><span class="s">&#39;dataset&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
</section>
<section id="save-meeg-data-when-i-get-the-error-value-for-fdim-channel-label-is-not-supported">
<h3><a class="toc-backref" href="#id88" role="doc-backlink">Save MEEG data when I get the error “value for fdim channel label is not supported”?</a><a class="headerlink" href="#save-meeg-data-when-i-get-the-error-value-for-fdim-channel-label-is-not-supported" title="Link to this heading">¶</a></h3>
<p>‘When I try to export MEEG searchlight maps with channel information as MEEG data using <code class="docutils literal notranslate"><span class="pre">cosmo_map2meeg(ds,'-dattimef')</span></code>, I get the error “value for fdim channel label is not supported”? Also I am unable to visualize the data in FieldTrip. Any idea how to fix this?’</p>
<p>This is probably caused by a wrong feature dimension order when crossing the neighborhood with <a class="reference internal" href="matlab/cosmo_cross_neighborhood.html#cosmo-cross-neighborhood"><span class="std std-ref">cosmo cross neighborhood</span></a>. The FieldTrip convention for the order is <code class="docutils literal notranslate"><span class="pre">'chan','time'</span></code> (for time-locked data) or <code class="docutils literal notranslate"><span class="pre">'chan','time','freq'</span></code> (for time-frequency data). (As of 16 December 2016, a warning has been added if a non-standard dimension order is detected).</p>
<p>It is possible to change the feature dimension order afterwards. First, the feature dimension order for a dataset struct <code class="docutils literal notranslate"><span class="pre">ds</span></code> can be displayed by running:</p>
<blockquote>
<div><div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="nb">disp</span><span class="p">(</span><span class="n">ds</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">fdim</span><span class="p">.</span><span class="n">labels</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>If the order is, for example, <code class="docutils literal notranslate"><span class="pre">'freq',</span> <span class="pre">'time',</span> <span class="pre">'chan'</span></code> then the channel dimension should be moved from position 3 to position 1 to become <code class="docutils literal notranslate"><span class="pre">'chan','freq','time'</span></code>. To move the channel dimension, first remove the dimension, than insert it at another position, as follows:</p>
<blockquote>
<div><div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">label_to_move</span><span class="p">=</span><span class="s">&#39;chan&#39;</span><span class="p">;</span>
<span class="n">target_pos</span><span class="p">=</span><span class="mi">1</span><span class="p">;</span>
<span class="p">[</span><span class="n">ds</span><span class="p">,</span><span class="n">attr</span><span class="p">,</span><span class="nb">values</span><span class="p">]=</span><span class="n">cosmo_dim_remove</span><span class="p">(</span><span class="n">ds</span><span class="p">,{</span><span class="n">label_to_move</span><span class="p">});</span>
<span class="n">ds</span><span class="p">=</span><span class="n">cosmo_dim_insert</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">target_pos</span><span class="p">,{</span><span class="n">label_to_move</span><span class="p">},</span><span class="nb">values</span><span class="p">,</span><span class="n">attr</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
</section>
<section id="run-a-2-x-2-within-subject-anova">
<h3><a class="toc-backref" href="#id89" role="doc-backlink">Run a 2 x 2 within-subject ANOVA?</a><a class="headerlink" href="#run-a-2-x-2-within-subject-anova" title="Link to this heading">¶</a></h3>
<p>‘I would like to run a 2 x 2 ANOVA over participants where both factors are within-participant (also known as repeated-measures ANOVA). Can I use CoSMoMVPA to get the main effects and interaction statistics?’</p>
<p>You can, but currently not directly: it involves a bit of manual work. The key thing is that in a 2 x 2 repeated measures ANOVA, main effects and interaction can all be expressed as one-sample t-tests. Say that for a single participant there are four conditions: A1, A2, B1, and B2. In CoSMoMVPA we would express this as a dataset structure <code class="docutils literal notranslate"><span class="pre">ds</span></code> with <code class="docutils literal notranslate"><span class="pre">ds.samples</span></code> of size <code class="docutils literal notranslate"><span class="pre">4</span> <span class="pre">x</span> <span class="pre">NF</span></code>, where <code class="docutils literal notranslate"><span class="pre">NF</span></code> is the number of features. Now compute:</p>
<blockquote>
<div><div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="c">% main effect A vs B: A1+A2-B1-B2.</span>
<span class="n">dsAvsB</span><span class="p">=</span><span class="n">cosmo_slice</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="n">dsAvsB</span><span class="p">.</span><span class="n">samples</span><span class="p">=</span><span class="n">ds</span><span class="p">.</span><span class="n">samples</span><span class="p">(</span><span class="mi">1</span><span class="p">,:)</span><span class="o">+</span><span class="n">ds</span><span class="p">.</span><span class="n">samples</span><span class="p">(</span><span class="mi">2</span><span class="p">,:)</span><span class="o">-</span><span class="n">ds</span><span class="p">.</span><span class="n">samples</span><span class="p">(</span><span class="mi">3</span><span class="p">,:)</span><span class="o">-</span><span class="n">ds</span><span class="p">.</span><span class="n">samples</span><span class="p">(</span><span class="mi">4</span><span class="p">,:)</span>

<span class="c">% main effect 1 vs 2: A1-A2+B1-B2</span>
<span class="n">ds1VS2</span><span class="p">=</span><span class="n">cosmo_slice</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="n">ds1VS2</span><span class="w"> </span><span class="p">=</span><span class="n">ds</span><span class="p">.</span><span class="n">samples</span><span class="p">(</span><span class="mi">1</span><span class="p">,:)</span><span class="o">-</span><span class="n">ds</span><span class="p">.</span><span class="n">samples</span><span class="p">(</span><span class="mi">2</span><span class="p">,:)</span><span class="o">+</span><span class="n">ds</span><span class="p">.</span><span class="n">samples</span><span class="p">(</span><span class="mi">3</span><span class="p">,:)</span><span class="o">-</span><span class="n">ds</span><span class="p">.</span><span class="n">samples</span><span class="p">(</span><span class="mi">4</span><span class="p">,:)</span>

<span class="c">% interaction: A1-A2-B1+B2</span>
<span class="n">dsinteraction</span><span class="p">=</span><span class="n">cosmo_slice</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="n">dsinteraction</span><span class="p">=</span><span class="n">ds</span><span class="p">.</span><span class="n">samples</span><span class="p">(</span><span class="mi">1</span><span class="p">,:)</span><span class="o">-</span><span class="n">ds</span><span class="p">.</span><span class="n">samples</span><span class="p">(</span><span class="mi">2</span><span class="p">,:)</span><span class="o">-</span><span class="n">ds</span><span class="p">.</span><span class="n">samples</span><span class="p">(</span><span class="mi">3</span><span class="p">,:)</span><span class="o">+</span><span class="n">ds</span><span class="p">.</span><span class="n">samples</span><span class="p">(</span><span class="mi">4</span><span class="p">,:)</span>
</pre></div>
</div>
</div></blockquote>
<p>Repeat the process for each participant. For each analysis of interest (two main effects and the interaction) separately, follow the process of a one-sample t-test as explained elsewhere in the FAQ: stack the dataset from the participants using <a class="reference internal" href="matlab/cosmo_stack.html#cosmo-stack"><span class="std std-ref">cosmo stack</span></a>, assign <code class="docutils literal notranslate"><span class="pre">.sa.chunks</span></code> to be all unique, assign <code class="docutils literal notranslate"><span class="pre">.sa.targets</span></code> to be all the same, and then use <a class="reference internal" href="matlab/cosmo_stat.html#cosmo-stat"><span class="std std-ref">cosmo stat</span></a> (for feature-wise stats with no correction for multiple correction) or <a class="reference internal" href="matlab/cosmo_montecarlo_cluster_stat.html#cosmo-montecarlo-cluster-stat"><span class="std std-ref">cosmo montecarlo cluster stat</span></a> (for correction with multiple comparisons).</p>
<p>Note the advantage of a (signed) t-test over an (always positive) F value: the t value tells you which way the main effect or interaction goes, whereas the F value does not tell this.</p>
</section>
<section id="use-a-fieldtrip-source-dataset-that-uses-a-fake-channel-structure">
<h3><a class="toc-backref" href="#id90" role="doc-backlink">Use a FieldTrip source dataset that uses a ‘fake’ channel structure</a><a class="headerlink" href="#use-a-fieldtrip-source-dataset-that-uses-a-fake-channel-structure" title="Link to this heading">¶</a></h3>
<p>‘I use an analysis pipeline where MEEG source data in MNI space is represented (faked) as a sensor-like structure [such as done by some at CIMeC, Trento; or University of Salzberg, Austria]. In particular, the FieldTrip dataset structure is</p>
<blockquote>
<div><div class="highlight-text notranslate"><div class="highlight"><pre><span></span>src_ft =

    label: {2982x1 cell}
   dimord: &#39;chan_freq_time&#39;
     freq: [1x25 double]
     time: [1x15 double]
powspctrm: [2982x25x15 double]
      cfg: [1x1 struct]
</pre></div>
</div>
</div></blockquote>
<p>where the labels are strings from <code class="docutils literal notranslate"><span class="pre">'1'</span></code> to <code class="docutils literal notranslate"><span class="pre">'2972'</span></code>. These labels refer to positions in source space using</p>
<blockquote>
<div><div class="highlight-text notranslate"><div class="highlight"><pre><span></span>template_grid =`

 xgrid: [-8 -7 -6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 7 8]
 ygrid: [-11 -10 -9 -8 -7 -6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 7 8]
 zgrid: [-7 -6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 7 8 9]
   dim: [17 20 17]
   pos: [5780x3 double]
  unit: &#39;cm&#39;
inside: [5780x1 logical]
   cfg: [1x1 struct]
</pre></div>
</div>
</div></blockquote>
<p>where there are 2972 positions in the .inside field that are equal to <code class="docutils literal notranslate"><span class="pre">true</span></code> representing the voxels in the brain. How can I use these dataset structures in CoSMoMVPA?’</p>
<p>The <code class="docutils literal notranslate"><span class="pre">src_ft</span></code> struct can be converted to a dataset structure using</p>
<blockquote>
<div><div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">src_ds</span><span class="p">=</span><span class="n">cosmo_meeg_dataset</span><span class="p">(</span><span class="n">src_ft</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>but it uses channel labels (representing voxels) for which the positions are not known (and thus, neighborhoods cannot be used). To add the position information, you can use the following helper function</p>
<blockquote>
<div><div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="k">function</span><span class="w"> </span>ds<span class="p">=</span><span class="nf">convert_ds_mni_grid</span><span class="p">(</span>ds,template_grid<span class="p">)</span>
<span class="c">% Converts dataset with &#39;fake&#39; channels numbered &#39;1&#39; to &#39;N&#39; (N numeric)</span>
<span class="c">% and an mni template structure</span>
<span class="c">%</span>
<span class="c">% Inputs:</span>
<span class="c">%   ds              dataset struct with first fdim dimension being</span>
<span class="c">%                   &#39;chan&#39; with &quot;fake&quot; channels representing MEEG source</span>
<span class="c">%                   structure</span>
<span class="c">%   template_grid   struct with fields .{x,y,z}grid and .inside</span>


<span class="w">    </span><span class="n">check_inputs</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span><span class="n">template_grid</span><span class="p">);</span>

<span class="w">    </span><span class="c">% voxels representing the brain</span>
<span class="w">    </span><span class="n">inside</span><span class="p">=</span><span class="n">template_grid</span><span class="p">.</span><span class="n">inside</span><span class="p">;</span>
<span class="w">    </span><span class="n">pos</span><span class="p">=</span><span class="n">template_grid</span><span class="p">.</span><span class="n">pos</span><span class="p">(</span><span class="n">inside</span><span class="p">,:)</span><span class="o">&#39;</span><span class="p">;</span>

<span class="w">    </span><span class="c">% change first dimension to position</span>
<span class="w">    </span><span class="n">ds</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">fdim</span><span class="p">.</span><span class="n">values</span><span class="p">{</span><span class="mi">1</span><span class="p">}=</span><span class="n">pos</span><span class="p">;</span>
<span class="w">    </span><span class="n">ds</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">fdim</span><span class="p">.</span><span class="n">labels</span><span class="p">{</span><span class="mi">1</span><span class="p">}=</span><span class="s">&#39;pos&#39;</span><span class="p">;</span>
<span class="w">    </span><span class="n">chan</span><span class="p">=</span><span class="n">ds</span><span class="p">.</span><span class="n">fa</span><span class="p">.</span><span class="n">chan</span><span class="p">;</span>
<span class="w">    </span><span class="n">ds</span><span class="p">.</span><span class="n">fa</span><span class="p">=</span><span class="nb">rmfield</span><span class="p">(</span><span class="n">ds</span><span class="p">.</span><span class="n">fa</span><span class="p">,</span><span class="s">&#39;chan&#39;</span><span class="p">);</span>
<span class="w">    </span><span class="n">ds</span><span class="p">.</span><span class="n">fa</span><span class="p">.</span><span class="n">pos</span><span class="p">=</span><span class="n">chan</span><span class="p">;</span>

<span class="w">    </span><span class="c">% sanity check</span>
<span class="w">    </span><span class="n">cosmo_check_dataset</span><span class="p">(</span><span class="n">ds</span><span class="p">);</span>

<span class="k">function</span><span class="w"> </span><span class="nf">check_inputs</span><span class="p">(</span>ds,template_grid<span class="p">)</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nb">isfield</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span><span class="s">&#39;label&#39;</span><span class="p">)</span>
<span class="w">        </span><span class="nb">error</span><span class="p">([</span><span class="s">&#39;First input is not a CoSMo dataset structure. &#39;</span><span class="k">...</span>
<span class="w">                </span><span class="s">&#39;Use cosmo_meeg_dataset to convert to a CoSMo structure&#39;</span><span class="p">]);</span>
<span class="w">    </span><span class="k">end</span>

<span class="w">    </span><span class="n">cosmo_check_dataset</span><span class="p">(</span><span class="n">ds</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="o">~</span><span class="nb">isequal</span><span class="p">(</span><span class="n">ds</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">fdim</span><span class="p">.</span><span class="n">labels</span><span class="p">{</span><span class="mi">1</span><span class="p">},</span><span class="s">&#39;chan&#39;</span><span class="p">)</span>
<span class="w">        </span><span class="nb">error</span><span class="p">(</span><span class="s">&#39;First fdim must be channel&#39;</span><span class="p">);</span>
<span class="w">    </span><span class="k">end</span>

<span class="w">    </span><span class="n">raise</span><span class="p">=</span><span class="nb">true</span><span class="p">;</span>
<span class="w">    </span><span class="n">cosmo_isfield</span><span class="p">(</span><span class="n">template_grid</span><span class="p">,</span><span class="k">...</span>
<span class="w">                    </span><span class="p">{</span><span class="s">&#39;xgrid&#39;</span><span class="p">,</span><span class="s">&#39;ygrid&#39;</span><span class="p">,</span><span class="s">&#39;zgrid&#39;</span><span class="p">,</span><span class="s">&#39;pos&#39;</span><span class="p">,</span><span class="s">&#39;inside&#39;</span><span class="p">},</span><span class="k">...</span>
<span class="w">                    </span><span class="n">raise</span><span class="p">);</span>

<span class="w">    </span><span class="n">labels</span><span class="p">=</span><span class="n">ds</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">fdim</span><span class="p">.</span><span class="n">values</span><span class="p">{</span><span class="mi">1</span><span class="p">};</span>
<span class="w">    </span><span class="n">n_inside</span><span class="p">=</span><span class="nb">sum</span><span class="p">(</span><span class="n">template_grid</span><span class="p">.</span><span class="n">inside</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">n_inside</span><span class="o">~=</span><span class="nb">numel</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
<span class="w">        </span><span class="nb">error</span><span class="p">(</span><span class="s">&#39;Source count mismatch: %d ~= %d&#39;</span><span class="p">,</span><span class="w"> </span><span class="n">n_inside</span><span class="p">,</span><span class="w"> </span><span class="nb">numel</span><span class="p">(</span><span class="n">labels</span><span class="p">));</span>
<span class="w">    </span><span class="k">end</span>

<span class="w">    </span><span class="n">numeric_labels</span><span class="p">=</span><span class="nb">cellfun</span><span class="p">(@</span><span class="nb">str2num</span><span class="p">,</span><span class="n">labels</span><span class="p">,</span><span class="s">&#39;UniformOutput&#39;</span><span class="p">,</span><span class="nb">false</span><span class="p">);</span>
<span class="w">    </span><span class="n">expected_numeric_labels</span><span class="p">=</span><span class="nb">arrayfun</span><span class="p">(@(</span><span class="n">x</span><span class="p">)</span><span class="n">x</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="n">n_inside</span><span class="p">,</span><span class="k">...</span>
<span class="w">                            </span><span class="s">&#39;UniformOutput&#39;</span><span class="p">,</span><span class="nb">false</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="o">~</span><span class="nb">isequal</span><span class="p">(</span><span class="n">expected_numeric_labels</span><span class="p">,</span><span class="n">numeric_labels</span><span class="p">)</span>
<span class="w">        </span><span class="nb">error</span><span class="p">([</span><span class="s">&#39;Labels are not as expected. This could mean that &#39;</span><span class="k">...</span>
<span class="w">                </span><span class="s">&#39;you are using this function not as intended. &#39;</span><span class="k">...</span>
<span class="w">                </span><span class="s">&#39;Proceed carefully&#39;</span><span class="p">]);</span>
<span class="w">    </span><span class="k">end</span>
</pre></div>
</div>
</div></blockquote>
<p>and then get a ‘proper’ dataset in source space using</p>
<blockquote>
<div><div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">ds</span><span class="p">=</span><span class="n">convert_ds_mni_grid</span><span class="p">(</span><span class="n">src_ds</span><span class="p">,</span><span class="n">template_grid</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
</section>
<section id="run-cosmo-montecarlo-cluster-stat-on-a-cluster-with-multiple-nodes">
<h3><a class="toc-backref" href="#id91" role="doc-backlink">Run <cite>cosmo_montecarlo_cluster_stat</cite> on a cluster with multiple nodes</a><a class="headerlink" href="#run-cosmo-montecarlo-cluster-stat-on-a-cluster-with-multiple-nodes" title="Link to this heading">¶</a></h3>
<p>‘I am running group statistics using <a class="reference internal" href="matlab/cosmo_montecarlo_cluster_stat.html#cosmo-montecarlo-cluster-stat"><span class="std std-ref">cosmo montecarlo cluster stat</span></a> but it is very slow when using the recommended 10,000 iterations. I have access to a computer cluster. Can I use the cluster to speed up the computations?’</p>
<p>Yes, although it requires a bit of extra work. You would run  <a class="reference internal" href="matlab/cosmo_montecarlo_cluster_stat.html#cosmo-montecarlo-cluster-stat"><span class="std std-ref">cosmo montecarlo cluster stat</span></a> on multiple computer nodes with fewer iterations, then combine their results. Consider the following script (and comments in there):</p>
<blockquote>
<div><div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="c">% example on combining results of multiple invocations of</span>
<span class="c">% cosmo_montecarlo_cluster_stat into a single dataset with effectively</span>
<span class="c">% more iterations</span>
<span class="c">%</span>
<span class="c">% Use case: running 10,000 iterations with cosmo_montecarlo_cluster_stat</span>
<span class="c">% on a single machine takes to long, but there are 50 computer nodes</span>
<span class="c">% available in a computer cluster. Then each node can do 200 iterations;</span>
<span class="c">% results from each node are combined afterwards to get</span>
<span class="c">% effectively 10,000 iteraations</span>
<span class="c">%</span>

<span class="c">% generate some random data for 20 participants</span>
<span class="n">nsubjects</span><span class="p">=</span><span class="mi">20</span><span class="p">;</span>
<span class="n">ds</span><span class="p">=</span><span class="n">cosmo_synthetic_dataset</span><span class="p">(</span><span class="s">&#39;ntargets&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="s">&#39;nchunks&#39;</span><span class="p">,</span><span class="n">nsubjects</span><span class="p">,</span><span class="k">...</span>
<span class="w">                        </span><span class="s">&#39;sigma&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="s">&#39;size&#39;</span><span class="p">,</span><span class="s">&#39;normal&#39;</span><span class="p">,</span><span class="s">&#39;seed&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>

<span class="c">% Generate TFCE z-scores in 50 blocks, each with 20 iterations.</span>
<span class="c">%</span>
<span class="c">% In this example a simple for-loop is used to compute results for each</span>
<span class="c">% block, but typically results in each block are computed in different</span>
<span class="c">% Matlab sessions (e.g. when using multiple computer nodes in a clusters).</span>
<span class="c">% In that case, a script or function should be used that stores the result</span>
<span class="c">% (a dataset with TFCE z-scores) for each block in a .mat file. For</span>
<span class="c">% example, the following function could be run on each computing node (each</span>
<span class="c">% with a different value for block_id):</span>
<span class="c">%</span>
<span class="c">%     function run_tfce_block(block_id,niter_per_block)</span>
<span class="c">%</span>
<span class="c">%     % load dataset with data from each subject</span>
<span class="c">%     ds=load(&#39;my_subject_data.mat&#39;);</span>
<span class="c">%</span>
<span class="c">%     % define neighborhood</span>
<span class="c">%     nh=cosmo_cluster_neighborhood(ds);</span>
<span class="c">%</span>
<span class="c">%     % set TFCE options</span>
<span class="c">%     opt=struct();</span>
<span class="c">%     opt.niter=niter_per_block;</span>
<span class="c">%     opt.h0_mean=0;</span>
<span class="c">%     opt.seed=block_id;</span>
<span class="c">%</span>
<span class="c">%     % compute TFCE z-scores</span>
<span class="c">%     z_ds=cosmo_montecarlo_cluster_stat(ds,nh,opt);</span>
<span class="c">%</span>
<span class="c">%     % save results to disk</span>
<span class="c">%     fn=sprintf(&#39;tfce_z_block%02d.mat&#39;,block_id);</span>
<span class="c">%     save(fn,&#39;-struct&#39;,&#39;z_ds&#39;);</span>
<span class="c">%</span>
<span class="c">% After running this function for aech block, the resulting .mat files</span>
<span class="c">% would then be loaded and combined with cosmo_stack as illustrated below.</span>
<span class="c">%</span>
<span class="c">% If a seed is set for cosmo_montecarlo_cluster_stat, then it is crucial</span>
<span class="c">% that different seed values are used in different blocks (otherwise each</span>
<span class="c">% block would yield identical results)</span>

<span class="n">nblocks</span><span class="p">=</span><span class="mi">50</span><span class="p">;</span>
<span class="n">niter_per_block</span><span class="p">=</span><span class="mi">20</span><span class="p">;</span>

<span class="n">ds_tfce_cell</span><span class="p">=</span><span class="nb">cell</span><span class="p">(</span><span class="n">nblocks</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="k">for</span><span class="w"> </span><span class="n">k</span><span class="p">=</span><span class="mi">1</span><span class="p">:</span><span class="n">nblocks</span>
<span class="w">    </span><span class="c">% Set TFCE options for each block.</span>
<span class="w">    </span><span class="c">% A different seed value is used for each block to obtain repeatable</span>
<span class="w">    </span><span class="c">% (determnistic) but different results in each block</span>
<span class="w">    </span><span class="n">opt</span><span class="p">=</span><span class="nb">struct</span><span class="p">();</span>
<span class="w">    </span><span class="n">opt</span><span class="p">.</span><span class="n">niter</span><span class="p">=</span><span class="n">niter_per_block</span><span class="p">;</span>
<span class="w">    </span><span class="n">opt</span><span class="p">.</span><span class="n">h0_mean</span><span class="p">=</span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">opt</span><span class="p">.</span><span class="n">seed</span><span class="p">=</span><span class="n">k</span><span class="p">;</span>

<span class="w">    </span><span class="c">% define the neighborhood</span>
<span class="w">    </span><span class="n">nbrhood</span><span class="p">=</span><span class="n">cosmo_cluster_neighborhood</span><span class="p">(</span><span class="n">ds</span><span class="p">);</span>

<span class="w">    </span><span class="c">% compute TFCE z-scores</span>
<span class="w">    </span><span class="n">ds_tfce_k</span><span class="p">=</span><span class="n">cosmo_montecarlo_cluster_stat</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span><span class="n">nbrhood</span><span class="p">,</span><span class="n">opt</span><span class="p">);</span>

<span class="w">    </span><span class="c">% store result</span>
<span class="w">    </span><span class="n">ds_tfce_cell</span><span class="p">{</span><span class="n">k</span><span class="p">}=</span><span class="n">ds_tfce_k</span><span class="p">;</span>
<span class="k">end</span>

<span class="c">% combine TFCE z-scores from all blocks into one dataset</span>
<span class="c">% (due to a tail cutoff protection this approach is very minorly</span>
<span class="c">% conservative in its p-value computation)</span>
<span class="n">ds_tfce_all</span><span class="p">=</span><span class="n">cosmo_stack</span><span class="p">(</span><span class="n">ds_tfce_cell</span><span class="p">);</span>

<span class="c">% convert TFCE z-scores to TFCE p-values</span>
<span class="c">% (the p-values represent the left tail probability)</span>
<span class="n">ps_all</span><span class="p">=</span><span class="n">normcdf</span><span class="p">(</span><span class="n">ds_tfce_all</span><span class="p">.</span><span class="n">samples</span><span class="p">);</span>

<span class="c">% compute the average p value over blocks, for each feature separately</span>
<span class="n">combined_ps</span><span class="p">=</span><span class="nb">mean</span><span class="p">(</span><span class="n">ps_all</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>

<span class="c">% convert TFCE p value back to TFCE z-scores</span>
<span class="n">combined_z</span><span class="p">=</span><span class="n">norminv</span><span class="p">(</span><span class="n">combined_ps</span><span class="p">);</span>

<span class="c">% make a new dataset in which the combined z-scores</span>
<span class="c">% are going to be stored</span>
<span class="n">ds_tfce</span><span class="p">=</span><span class="n">cosmo_slice</span><span class="p">(</span><span class="n">ds_tfce_all</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>

<span class="c">% ensure empty sample attributes</span>
<span class="n">ds_tfce</span><span class="p">.</span><span class="n">sa</span><span class="p">=</span><span class="nb">struct</span><span class="p">();</span>

<span class="c">% store dataset</span>
<span class="n">ds_tfce</span><span class="p">.</span><span class="n">samples</span><span class="p">=</span><span class="n">combined_z</span><span class="p">;</span>
<span class="n">cosmo_check_dataset</span><span class="p">(</span><span class="n">ds_tfce</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
</section>
<section id="why-should-i-consider-re-meaning-when-doing-representational-similarity-analysis-rsa">
<h3><a class="toc-backref" href="#id92" role="doc-backlink">Why should I consider re-meaning when doing representational similarity analysis (RSA)?</a><a class="headerlink" href="#why-should-i-consider-re-meaning-when-doing-representational-similarity-analysis-rsa" title="Link to this heading">¶</a></h3>
<p>‘In the  <a class="reference internal" href="matlab/cosmo_target_dsm_corr_measure.html#cosmo-target-dsm-corr-measure"><span class="std std-ref">cosmo target dsm corr measure</span></a> documentation it is recommended to subtract the mean activity pattern first. Why is this recommended?’</p>
<p>This is explained well in <span id="id5">[<a class="reference internal" href="references.html#id5" title="Diedrichsen, J. and Kriegeskorte, N. Representational models: a common framework for understanding encoding, pattern-component, and representational-similarity analysis. PLoS computational biology, 13(4):e1005508, 2017.">DK17</a>]</span>:</p>
<p>‘Activity estimates commonly co-vary together across fMRI imaging runs, because all activity estimates within a partition are measured relative to the same resting baseline. This positive correlation can be reduced by subtracting, within each partition, the mean activity pattern (across conditions) from each activity pattern. This makes the mean of each measurement channel (across condition) zero and thus centers the ensemble of points in activity-pattern space that is centered on the origin.’</p>
</section>
<section id="import-brainstorm-data">
<h3><a class="toc-backref" href="#id93" role="doc-backlink">Import BrainStorm data</a><a class="headerlink" href="#import-brainstorm-data" title="Link to this heading">¶</a></h3>
<p>‘I have preprocessed my data using BrainStorm. How can I import time-locked and time-frequency data in CoSMoMVPA?’</p>
<p>Currently this functionality is not included in <a class="reference internal" href="matlab/cosmo_meeg_dataset.html#cosmo-meeg-dataset"><span class="std std-ref">cosmo meeg dataset</span></a>, but below are some example scripts that illustrate the approach.</p>
<p>For time-locked data:</p>
<blockquote>
<div><div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="c">% Example script showing importing BrainStorm M/EEG time-locked data into</span>
<span class="c">% CoSMoMVPA.</span>
<span class="c">%</span>
<span class="c">% The result is a CoSMoMVPA dataset structure &#39;ds&#39;</span>
<span class="c">%</span>
<span class="c">% NNO Sep 2017</span>
<span class="c">%</span>
<span class="c">% Input data:</span>
<span class="c">%   &#39;195_trial001.mat&#39; : contains data in FieldTrip timelock struct format,</span>
<span class="c">%                        with data from a single trial, for 701 time points</span>
<span class="c">%                        and 319 channels</span>
<span class="c">%</span>
<span class="c">%                             template_trial =</span>
<span class="c">%</span>
<span class="c">%                                 dimord: &#39;chan_time&#39;</span>
<span class="c">%                                    avg: [319x701 double]</span>
<span class="c">%                                   time: [1x701 double]</span>
<span class="c">%                                  label: {319x1 cell}</span>
<span class="c">%                                   grad: [1x1 struct]</span>
<span class="c">%</span>
<span class="c">%   &#39;out.mat&#39;          : 3D array of size 180 x 319 x 701</span>
<span class="c">%                           180 trials, 90 of condition A followed by</span>
<span class="c">%                                       90 of condition B</span>
<span class="c">%                           319 channels</span>
<span class="c">%                           701 time points</span>
<span class="c">%</span>

<span class="c">% Indices of the trial conditions</span>
<span class="c">% - the first 90 trials are condition A</span>
<span class="c">% - the nextt 90 trials are condition B</span>
<span class="n">trials_condA</span><span class="p">=</span><span class="mi">1</span><span class="p">:</span><span class="mi">90</span><span class="p">;</span>
<span class="n">trials_condB</span><span class="p">=</span><span class="mi">91</span><span class="p">:</span><span class="mi">180</span><span class="p">;</span>

<span class="c">% load all data</span>
<span class="n">all_data</span><span class="p">=</span><span class="nb">importdata</span><span class="p">(</span><span class="s">&#39;out.mat&#39;</span><span class="p">);</span>

<span class="c">% get template trial</span>
<span class="n">template_trial</span><span class="p">=</span><span class="nb">load</span><span class="p">(</span><span class="s">&#39;195_trial001.mat&#39;</span><span class="p">);</span>

<span class="c">% set trial condition in a vector</span>
<span class="n">targets</span><span class="p">=</span><span class="nb">NaN</span><span class="p">(</span><span class="nb">numel</span><span class="p">(</span><span class="n">trials_condA</span><span class="p">)</span><span class="o">+</span><span class="nb">numel</span><span class="p">(</span><span class="n">trials_condA</span><span class="p">),</span><span class="mi">1</span><span class="p">);</span>
<span class="n">targets</span><span class="p">(</span><span class="n">trials_condA</span><span class="p">)=</span><span class="mi">1</span><span class="p">;</span>
<span class="n">targets</span><span class="p">(</span><span class="n">trials_condB</span><span class="p">)=</span><span class="mi">2</span><span class="p">;</span>

<span class="c">% count number of trials</span>
<span class="n">n_trials</span><span class="p">=</span><span class="nb">numel</span><span class="p">(</span><span class="n">targets</span><span class="p">);</span>

<span class="c">% just verify that trial count matches</span>
<span class="nb">assert</span><span class="p">(</span><span class="nb">numel</span><span class="p">(</span><span class="n">targets</span><span class="p">)</span><span class="o">==</span><span class="nb">size</span><span class="p">(</span><span class="n">all_data</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="s">&#39;trial count mismatch&#39;</span><span class="p">);</span>

<span class="c">% allocate space for output</span>
<span class="n">ds_cell</span><span class="p">=</span><span class="nb">cell</span><span class="p">(</span><span class="n">n_trials</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>

<span class="c">% convert each trial</span>
<span class="k">for</span><span class="w"> </span><span class="n">k</span><span class="p">=</span><span class="mi">1</span><span class="p">:</span><span class="n">n_trials</span>
<span class="w">    </span><span class="c">% make a copy from the template</span>
<span class="w">    </span><span class="n">trial</span><span class="p">=</span><span class="n">template_trial</span><span class="p">;</span>

<span class="w">    </span><span class="c">% take data from trial</span>
<span class="w">    </span><span class="n">trial</span><span class="p">.</span><span class="n">avg</span><span class="p">(:,:)=</span><span class="nb">squeeze</span><span class="p">(</span><span class="n">all_data</span><span class="p">(</span><span class="n">k</span><span class="p">,:,:));</span>

<span class="w">    </span><span class="c">% convert to CoSMo struct</span>
<span class="w">    </span><span class="n">ds_trial</span><span class="p">=</span><span class="n">cosmo_meeg_dataset</span><span class="p">(</span><span class="n">trial</span><span class="p">);</span>

<span class="w">    </span><span class="c">% all trials are assumed to be independent</span>
<span class="w">    </span><span class="n">ds_trial</span><span class="p">.</span><span class="n">sa</span><span class="p">.</span><span class="n">chunks</span><span class="p">=</span><span class="n">k</span><span class="p">;</span>

<span class="w">    </span><span class="c">% set condition</span>
<span class="w">    </span><span class="n">ds_trial</span><span class="p">.</span><span class="n">sa</span><span class="p">.</span><span class="n">targets</span><span class="p">=</span><span class="n">targets</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>

<span class="w">    </span><span class="c">% since we are merging trials, this is not an average anymore</span>
<span class="w">    </span><span class="c">% (this is a bit of a hack since we&#39;re not really importing from</span>
<span class="w">    </span><span class="c">% FieldTrip, but BrainStorm sets (arguablye misleading) the single</span>
<span class="w">    </span><span class="c">% trial data as if it is an average)</span>
<span class="w">    </span><span class="n">ds_trial</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">meeg</span><span class="p">=</span><span class="nb">rmfield</span><span class="p">(</span><span class="n">ds_trial</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">meeg</span><span class="p">,</span><span class="s">&#39;samples_field&#39;</span><span class="p">);</span>

<span class="w">    </span><span class="c">% store dataset</span>
<span class="w">    </span><span class="n">ds_cell</span><span class="p">{</span><span class="n">k</span><span class="p">}=</span><span class="n">ds_trial</span><span class="p">;</span>
<span class="k">end</span>

<span class="c">% merge all trials into a big dataset</span>
<span class="n">ds</span><span class="p">=</span><span class="n">cosmo_stack</span><span class="p">(</span><span class="n">ds_cell</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>For time-frequency data:</p>
<blockquote>
<div><div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="c">% Brainstorm time-frequency data import in CoSMoMVPA</span>
<span class="c">%</span>
<span class="c">% The script below takes data from BrainStorm representing a single trial</span>
<span class="c">% in time-frequency space, and converts it to a CoSMoMVPA dataset</span>
<span class="c">% structure. The contents of TFmask (representing a mask) is applied.</span>
<span class="c">%</span>
<span class="c">% The input data bs_data (BrainStorm data) has the following structure:</span>
<span class="c">%</span>
<span class="c">%     bs_data =</span>
<span class="c">%</span>
<span class="c">%                TF: [306x701x60 double]</span>
<span class="c">%            TFmask: [60x701 logical]</span>
<span class="c">%           Comment: &#39;Power,1-60Hz (MEG)&#39;</span>
<span class="c">%          DataType: &#39;data&#39;</span>
<span class="c">%              Time: [1x701 double]</span>
<span class="c">%             Freqs: [1x60 double]</span>
<span class="c">%          RowNames: {1x306 cell}</span>
<span class="c">%           Measure: &#39;power&#39;</span>
<span class="c">%            Method: &#39;morlet&#39;</span>
<span class="c">%</span>
<span class="c">%           (with some fields omitted).</span>
<span class="c">%</span>

<span class="c">% bs_data contains time-freq data from BrainStorm</span>

<span class="n">tf_arr</span><span class="p">=</span><span class="n">bs_data</span><span class="p">.</span><span class="n">TF</span><span class="p">;</span>
<span class="n">tf_msk</span><span class="p">=</span><span class="n">bs_data</span><span class="p">.</span><span class="n">TFmask</span><span class="p">;</span>
<span class="n">n_chan</span><span class="p">=</span><span class="nb">size</span><span class="p">(</span><span class="n">tf_arr</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>

<span class="c">% get single trial data of size 1 x Nchan x NTime x NFreq</span>
<span class="n">tf_msk_tr</span><span class="p">=</span><span class="n">tf_msk</span><span class="o">&#39;</span><span class="p">;</span>
<span class="n">msk</span><span class="p">=</span><span class="nb">repmat</span><span class="p">(</span><span class="nb">reshape</span><span class="p">(</span><span class="n">tf_msk_tr</span><span class="p">,[</span><span class="mi">1</span><span class="w"> </span><span class="nb">size</span><span class="p">(</span><span class="n">tf_msk_tr</span><span class="p">)]),[</span><span class="n">n_chan</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span><span class="p">]);</span>

<span class="c">% sanity check that mask size matches TF data size</span>
<span class="nb">assert</span><span class="p">(</span><span class="nb">isequal</span><span class="p">(</span><span class="nb">size</span><span class="p">(</span><span class="n">msk</span><span class="p">),</span><span class="nb">size</span><span class="p">(</span><span class="n">tf_arr</span><span class="p">)));</span>

<span class="n">tf_4d</span><span class="p">=</span><span class="nb">reshape</span><span class="p">(</span><span class="n">tf_arr</span><span class="p">,[</span><span class="mi">1</span><span class="w"> </span><span class="nb">size</span><span class="p">(</span><span class="n">bs_data</span><span class="p">.</span><span class="n">TF</span><span class="p">)]);</span>
<span class="n">msk_4d</span><span class="p">=</span><span class="nb">reshape</span><span class="p">(</span><span class="n">msk</span><span class="p">,[</span><span class="mi">1</span><span class="w"> </span><span class="nb">size</span><span class="p">(</span><span class="n">msk</span><span class="p">)]);</span>

<span class="c">% make it a dataset</span>
<span class="n">labels</span><span class="p">={</span><span class="s">&#39;chan&#39;</span><span class="p">,</span><span class="s">&#39;time&#39;</span><span class="p">,</span><span class="s">&#39;freq&#39;</span><span class="p">};</span>
<span class="nb">values</span><span class="p">={</span><span class="n">bs_data</span><span class="p">.</span><span class="n">RowNames</span><span class="p">,</span><span class="n">bs_data</span><span class="p">.</span><span class="n">Time</span><span class="p">,</span><span class="n">bs_data</span><span class="p">.</span><span class="n">Freqs</span><span class="p">};</span>
<span class="n">full_ds</span><span class="p">=</span><span class="n">cosmo_flatten</span><span class="p">(</span><span class="n">tf_4d</span><span class="p">,</span><span class="n">labels</span><span class="p">,</span><span class="nb">values</span><span class="p">);</span>

<span class="c">% convert mask into dataset</span>
<span class="n">msk_ds</span><span class="p">=</span><span class="n">cosmo_flatten</span><span class="p">(</span><span class="n">msk_4d</span><span class="p">,</span><span class="n">labels</span><span class="p">,</span><span class="nb">values</span><span class="p">);</span>

<span class="c">% apply mask</span>
<span class="n">ds</span><span class="p">=</span><span class="n">cosmo_slice</span><span class="p">(</span><span class="n">full_ds</span><span class="p">,</span><span class="n">msk_ds</span><span class="p">.</span><span class="n">samples</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>

<span class="c">% label it as meeg data</span>
<span class="n">ds</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">meeg</span><span class="p">=</span><span class="nb">struct</span><span class="p">();</span>

<span class="c">% sanity check</span>
<span class="n">cosmo_check_dataset</span><span class="p">(</span><span class="n">ds</span><span class="p">);</span>

<span class="c">% illutration of mapping data to FieldTrip structure</span>
<span class="n">data_ft</span><span class="p">=</span><span class="n">cosmo_map2meeg</span><span class="p">(</span><span class="n">ds</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>Note that there is no example script (yet) showing how to transform this data back into BrainStorm.</p>
</section>
<section id="compute-the-correlation-between-two-dissimilarity-matrices">
<h3><a class="toc-backref" href="#id94" role="doc-backlink">Compute the correlation between two dissimilarity matrices</a><a class="headerlink" href="#compute-the-correlation-between-two-dissimilarity-matrices" title="Link to this heading">¶</a></h3>
<p>‘I would like to correlate behavioural ratings with a theoretical model, how can I do this’</p>
<p>You can use the example below to correlate two dissimilarity matrices. Note that instead of <code class="docutils literal notranslate"><span class="pre">cosmo_squareform</span></code> and <code class="docutils literal notranslate"><span class="pre">cosmo_corr</span></code> also the inbuilt <code class="docutils literal notranslate"><span class="pre">squareform</span></code> and <code class="docutils literal notranslate"><span class="pre">corr</span></code> functions can be used, if available.</p>
<blockquote>
<div><div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="c">% two dissimilarity matrices</span>
<span class="n">x_dsm</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">         </span><span class="n">1</span><span class="w"> </span><span class="s">0</span><span class="w"> </span><span class="s">3</span><span class="w"> </span><span class="s">4</span><span class="p">;</span>
<span class="w">         </span><span class="n">3</span><span class="w"> </span><span class="s">3</span><span class="w"> </span><span class="s">0</span><span class="w"> </span><span class="s">1</span><span class="p">;</span>
<span class="w">         </span><span class="n">2</span><span class="w"> </span><span class="s">4</span><span class="w"> </span><span class="s">1</span><span class="w"> </span><span class="s">0]</span><span class="p">;</span>

<span class="n">y_dsm</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">         </span><span class="n">5</span><span class="w"> </span><span class="s">0</span><span class="w"> </span><span class="s">1</span><span class="w"> </span><span class="s">2</span><span class="p">;</span>
<span class="w">         </span><span class="n">3</span><span class="w"> </span><span class="s">1</span><span class="w"> </span><span class="s">0</span><span class="w"> </span><span class="s">0</span><span class="p">;</span>
<span class="w">         </span><span class="n">1</span><span class="w"> </span><span class="s">2</span><span class="w"> </span><span class="s">0</span><span class="w"> </span><span class="s">0]</span><span class="p">;</span>

<span class="c">% convert to linear vectors</span>
<span class="n">x_vec</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">cosmo_squareform</span><span class="p">(</span><span class="n">x_dsm</span><span class="p">);</span>
<span class="n">y_vec</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">cosmo_squareform</span><span class="p">(</span><span class="n">y_dsm</span><span class="p">);</span>

<span class="c">% compute Spearman correlation between the matrices</span>
<span class="c">% ( - for non-Parametric Spearman correlations, use &#39;Spearman&#39;.)</span>
<span class="c">% ( - Matlab&#39;s corr can be used instead)</span>
<span class="n">r</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">cosmo_corr</span><span class="p">(</span><span class="n">x_vec</span><span class="p">(:),</span><span class="w"> </span><span class="n">y_vec</span><span class="p">(:),</span><span class="w"> </span><span class="s">&#39;Pearson&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>For analysis at the group level, compute for each participant the correlation between their behavioural ratings, then use a one-sample t-test against a difference of zero.</p>
</section>
<section id="use-the-generalization-measure-with-different-durations-for-training-and-test-set">
<h3><a class="toc-backref" href="#id95" role="doc-backlink">Use the generalization measure with different durations for training and test set?</a><a class="headerlink" href="#use-the-generalization-measure-with-different-durations-for-training-and-test-set" title="Link to this heading">¶</a></h3>
<p>‘I would like to use the <a class="reference internal" href="matlab/cosmo_dim_generalization_measure.html#cosmo-dim-generalization-measure"><span class="std std-ref">cosmo dim generalization measure</span></a> but with different time intervals for training and test set. For the training set I have 3 seconds of data per trial, but for the test set only 1 second. How can I run this analysis?’</p>
<p>Please see the code below for an example. It is similar to the documentation of <a class="reference internal" href="matlab/cosmo_dim_generalization_measure.html#cosmo-dim-generalization-measure"><span class="std std-ref">cosmo dim generalization measure</span></a>, except that in the preparation phase the <a class="reference internal" href="matlab/cosmo_dim_transpose.html#cosmo-dim-transpose"><span class="std std-ref">cosmo dim transpose</span></a>  step is done before the <a class="reference internal" href="matlab/cosmo_stack.html#cosmo-stack"><span class="std std-ref">cosmo stack</span></a> step. This order is also necessary when using <a class="reference internal" href="matlab/cosmo_searchlight.html#cosmo-searchlight"><span class="std std-ref">cosmo searchlight</span></a>.</p>
<blockquote>
<div><div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="c">% Generalization over time</span>

<span class="c">% Make some synthetic data</span>
<span class="n">sz</span><span class="p">=</span><span class="s">&#39;big&#39;</span><span class="p">;</span>
<span class="n">train_ds</span><span class="p">=</span><span class="n">cosmo_synthetic_dataset</span><span class="p">(</span><span class="s">&#39;type&#39;</span><span class="p">,</span><span class="s">&#39;timelock&#39;</span><span class="p">,</span><span class="s">&#39;size&#39;</span><span class="p">,</span><span class="n">sz</span><span class="p">,</span><span class="k">...</span>
<span class="w">                                       </span><span class="s">&#39;nchunks&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="s">&#39;seed&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="n">test_ds</span><span class="p">=</span><span class="n">cosmo_synthetic_dataset</span><span class="p">(</span><span class="s">&#39;type&#39;</span><span class="p">,</span><span class="s">&#39;timelock&#39;</span><span class="p">,</span><span class="s">&#39;size&#39;</span><span class="p">,</span><span class="n">sz</span><span class="p">,</span><span class="k">...</span>
<span class="w">                                       </span><span class="s">&#39;nchunks&#39;</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="s">&#39;seed&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>

<span class="c">% select a smaller time period for the testing dataset</span>
<span class="c">% here, only the time period between -0.15 and 0.05 seconds is selected</span>
<span class="n">msk</span><span class="p">=</span><span class="n">cosmo_dim_match</span><span class="p">(</span><span class="n">test_ds</span><span class="p">,</span><span class="w"> </span><span class="s">&#39;time&#39;</span><span class="p">,</span><span class="w"> </span><span class="p">@(</span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="mf">0.15</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mf">.05</span><span class="p">);</span>
<span class="n">smaller_test_ds</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">cosmo_slice</span><span class="p">(</span><span class="n">test_ds</span><span class="p">,</span><span class="w"> </span><span class="n">msk</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>

<span class="c">% set chunks</span>
<span class="n">train_ds</span><span class="p">.</span><span class="n">sa</span><span class="p">.</span><span class="n">chunks</span><span class="p">(:)=</span><span class="mi">1</span><span class="p">;</span>
<span class="n">smaller_test_ds</span><span class="p">.</span><span class="n">sa</span><span class="p">.</span><span class="n">chunks</span><span class="p">(:)=</span><span class="mi">2</span><span class="p">;</span>

<span class="c">% make time a sample dimension</span>
<span class="n">dim_label</span><span class="p">=</span><span class="s">&#39;time&#39;</span><span class="p">;</span>
<span class="n">train_ds_tr</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">cosmo_dim_transpose</span><span class="p">(</span><span class="n">train_ds</span><span class="p">,</span><span class="w"> </span><span class="n">dim_label</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="n">smaller_test_ds_tr</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">cosmo_dim_transpose</span><span class="p">(</span><span class="n">smaller_test_ds</span><span class="p">,</span><span class="w"> </span><span class="n">dim_label</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>

<span class="c">% construct the dataset</span>
<span class="n">ds_time</span><span class="p">=</span><span class="n">cosmo_stack</span><span class="p">({</span><span class="n">train_ds_tr</span><span class="p">,</span><span class="w"> </span><span class="n">smaller_test_ds_tr</span><span class="p">});</span>

<span class="c">%</span>
<span class="c">% set measure and its arguments</span>
<span class="n">measure_args</span><span class="p">=</span><span class="nb">struct</span><span class="p">();</span>
<span class="c">%</span>
<span class="c">% use correlation measure</span>
<span class="n">measure_args</span><span class="p">.</span><span class="n">measure</span><span class="p">=@</span><span class="n">cosmo_correlation_measure</span><span class="p">;</span>
<span class="c">% dimension of interest is &#39;time&#39;</span>
<span class="n">measure_args</span><span class="p">.</span><span class="n">dimension</span><span class="p">=</span><span class="n">dim_label</span><span class="p">;</span>
<span class="c">%</span>
<span class="c">% run time-by-time generalization analysis</span>
<span class="n">dgm_ds</span><span class="p">=</span><span class="n">cosmo_dim_generalization_measure</span><span class="p">(</span><span class="n">ds_time</span><span class="p">,</span><span class="n">measure_args</span><span class="p">,</span><span class="k">...</span>
<span class="w">                                        </span><span class="s">&#39;progress&#39;</span><span class="p">,</span><span class="nb">false</span><span class="p">);</span>
<span class="c">%</span>
<span class="c">% the output has train_time and test_time as sample dimensions</span>
<span class="n">cosmo_disp</span><span class="p">(</span><span class="n">dgm_ds</span><span class="p">.</span><span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
</section>
<section id="get-the-classifier-weights-after-training-a-classifier">
<h3><a class="toc-backref" href="#id96" role="doc-backlink">Get the classifier weights after training a classifier?</a><a class="headerlink" href="#get-the-classifier-weights-after-training-a-classifier" title="Link to this heading">¶</a></h3>
<p>‘Using ROI-based MVPA, I would like to know which voxels get a large weight to drve classification. How can I get these weights as output?’ [Original question on Google Groups by Lina T., 2018-01-08]</p>
<p>Getting the weights back is currently not supported, and there are no short-term plans to add this. Rationale: the searchlight does generally not work well together with the measure concept, as the measure must return a Nx1 .samples (column vector) dataset. So the only way to make this fit with feature weights is to return the weights, but this is problematic when different searchlight locations have a different number of features associated with them. But even when the number of features would match there is no clear correspondence for each row with a particular feature location. So it all becomes quite messy really.</p>
<p>It is also questionable how useful or interpretable these weights are, see <span id="id6">[<a class="reference internal" href="references.html#id10" title="Haufe, S., Meinecke, F., Görgen, K., Dähne, S., Haynes, J.-D., Blankertz, B., and Bießmann, F. On the interpretation of weight vectors of linear models in multivariate neuroimaging. Neuroimage, 87:96–110, 2014.">HMGorgen+14</a>]</span> :</p>
<blockquote>
<div><p>‘the interpretation of backward model [such as multivariate classifier] parameters can lead to wrong conclusions regarding the spatial or temporal origin of the neural signals of interest, since significant nonzero weights may also be observed at channels the activity of which is statistically independent of the brain process under study.’</p>
</div></blockquote>
<p>If you really want the classifier weights back, then you could write your own custom function, and maybe even a measure, if you want to use a searchlight.</p>
</section>
<section id="get-coordinates-of-voxels-in-a-cosmomvpa-fmri-dataset">
<h3><a class="toc-backref" href="#id97" role="doc-backlink">Get coordinates of voxels in a CoSMoMVPA fMRI dataset?</a><a class="headerlink" href="#get-coordinates-of-voxels-in-a-cosmomvpa-fmri-dataset" title="Link to this heading">¶</a></h3>
<p>These can be obtained using <a class="reference internal" href="matlab/cosmo_vol_coordinates.html#cosmo-vol-coordinates"><span class="std std-ref">cosmo vol coordinates</span></a>.</p>
</section>
<section id="compute-representational-similarity-across-chunks">
<h3><a class="toc-backref" href="#id98" role="doc-backlink">Compute representational similarity across chunks?</a><a class="headerlink" href="#compute-representational-similarity-across-chunks" title="Link to this heading">¶</a></h3>
<p>‘I have collected data in an fMRI study with 15 targets for run 1 (<code class="docutils literal notranslate"><span class="pre">chunks=1</span></code>) and another (disjoint set of) 15 targets in run 2 (<code class="docutils literal notranslate"><span class="pre">chunks=2</span></code>). I would like to compute the similarity for all 255 (=15*15) targets, but not for targets within the same chunk. How can I achieve this?  [Original question on Google Groups by Lyam B., 2020-09-15]</p>
<p>You could use the following code:</p>
<blockquote>
<div><div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="k">function</span><span class="w"> </span>ds_result<span class="p">=</span><span class="nf">my_across_chunks_dissimilarity_matrix_measure</span><span class="p">(</span>ds,opt<span class="p">)</span>
<span class="c">% compute dissimilarity across chunks</span>
<span class="c">%</span>
<span class="c">% ds_result=my_across_chunks_dissimilarity_matrix_measure(ds,opt)</span>
<span class="c">%</span>
<span class="c">% Input:</span>
<span class="c">%   ds              dataset struct with two unique values in ds.sa.chunks</span>
<span class="c">%   opt             optional options to be passed to</span>
<span class="c">%                   cosmo_dissimilarity_matrix_measure</span>
<span class="c">%</span>
<span class="c">% Output:</span>
<span class="c">%   ds_result       output dataset with all similarities computed between</span>
<span class="c">%                   samples with different values for chunks. Thus if the</span>
<span class="c">%                   input dataset has A values for the first chunk and B</span>
<span class="c">%                   for the second chunk, the output has A*B samples.</span>
<span class="c">%     .sa           sample attributes indicating</span>
<span class="c">%        .targets1  } target indices for the dissimilarity matrix, similar</span>
<span class="c">%        .targets2  } as in cosmo_dissimilarity_matrix_measure</span>
<span class="c">%        .t1         } the target (experimental condition) labels</span>
<span class="c">%        .t2         }</span>
<span class="c">%</span>
<span class="c">% See also: cosmo_dissimilarity_matrix_measure</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nb">nargin</span><span class="o">&lt;</span><span class="mi">2</span>
<span class="w">        </span><span class="n">opt</span><span class="p">=</span><span class="nb">struct</span><span class="p">();</span>
<span class="w">    </span><span class="k">end</span>

<span class="w">    </span><span class="n">dsm</span><span class="p">=</span><span class="n">cosmo_dissimilarity_matrix_measure</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span><span class="n">opt</span><span class="p">);</span>

<span class="w">    </span><span class="p">[</span><span class="n">chunk_idxs</span><span class="p">,</span><span class="w"> </span><span class="n">unq_chunks</span><span class="p">]=</span><span class="n">cosmo_index_unique</span><span class="p">(</span><span class="n">ds</span><span class="p">.</span><span class="n">sa</span><span class="p">.</span><span class="n">chunks</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nb">numel</span><span class="p">(</span><span class="n">unq_chunks</span><span class="p">)</span><span class="w"> </span><span class="o">~=</span><span class="w"> </span><span class="mi">2</span>
<span class="w">        </span><span class="nb">error</span><span class="p">(</span><span class="s">&#39;Expected two chunks&#39;</span><span class="p">);</span>
<span class="w">    </span><span class="k">end</span>

<span class="w">    </span><span class="c">% targets present in the two chunks</span>
<span class="w">    </span><span class="n">ch_t1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">ds</span><span class="p">.</span><span class="n">sa</span><span class="p">.</span><span class="n">targets</span><span class="p">(</span><span class="n">chunk_idxs</span><span class="p">{</span><span class="mi">1</span><span class="p">});</span>
<span class="w">    </span><span class="n">ch_t2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">ds</span><span class="p">.</span><span class="n">sa</span><span class="p">.</span><span class="n">targets</span><span class="p">(</span><span class="n">chunk_idxs</span><span class="p">{</span><span class="mi">2</span><span class="p">});</span>

<span class="w">    </span><span class="c">% two vectors should be disjoint</span>
<span class="w">    </span><span class="n">overlapping_msk</span><span class="p">=</span><span class="nb">bsxfun</span><span class="p">(@</span><span class="nb">eq</span><span class="p">,</span><span class="n">ch_t1</span><span class="p">,</span><span class="n">ch_t2</span><span class="o">&#39;</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nb">any</span><span class="p">(</span><span class="n">overlapping_msk</span><span class="p">(:))</span>
<span class="w">        </span><span class="nb">error</span><span class="p">(</span><span class="s">&#39;At least one target present in both chunks&#39;</span><span class="p">);</span>
<span class="w">    </span><span class="k">end</span>

<span class="w">    </span><span class="p">[</span><span class="n">unused</span><span class="p">,</span><span class="n">unq_t</span><span class="p">]=</span><span class="n">cosmo_index_unique</span><span class="p">(</span><span class="n">ds</span><span class="p">.</span><span class="n">sa</span><span class="p">.</span><span class="n">targets</span><span class="p">);</span>

<span class="w">    </span><span class="c">% find relevant rows in dsm</span>
<span class="w">    </span><span class="n">sa_t1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">unq_t</span><span class="p">(</span><span class="n">dsm</span><span class="p">.</span><span class="n">sa</span><span class="p">.</span><span class="n">targets1</span><span class="p">);</span>
<span class="w">    </span><span class="n">sa_t2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">unq_t</span><span class="p">(</span><span class="n">dsm</span><span class="p">.</span><span class="n">sa</span><span class="p">.</span><span class="n">targets2</span><span class="p">);</span>

<span class="w">    </span><span class="n">msk1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">cosmo_match</span><span class="p">(</span><span class="n">sa_t1</span><span class="p">,</span><span class="n">ch_t1</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">cosmo_match</span><span class="p">(</span><span class="n">sa_t2</span><span class="p">,</span><span class="n">ch_t2</span><span class="p">);</span>
<span class="w">    </span><span class="n">msk2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">cosmo_match</span><span class="p">(</span><span class="n">sa_t1</span><span class="p">,</span><span class="n">ch_t2</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">cosmo_match</span><span class="p">(</span><span class="n">sa_t2</span><span class="p">,</span><span class="n">ch_t1</span><span class="p">);</span>

<span class="w">    </span><span class="n">msk</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">msk1</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">msk2</span><span class="p">;</span>

<span class="w">    </span><span class="n">ds_result</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">cosmo_slice</span><span class="p">(</span><span class="n">dsm</span><span class="p">,</span><span class="w"> </span><span class="n">msk</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>
<span class="w">    </span><span class="n">ds_result</span><span class="p">.</span><span class="n">sa</span><span class="p">.</span><span class="n">t1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">unq_t</span><span class="p">(</span><span class="n">ds_result</span><span class="p">.</span><span class="n">sa</span><span class="p">.</span><span class="n">targets1</span><span class="p">);</span>
<span class="w">    </span><span class="n">ds_result</span><span class="p">.</span><span class="n">sa</span><span class="p">.</span><span class="n">t2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">unq_t</span><span class="p">(</span><span class="n">ds_result</span><span class="p">.</span><span class="n">sa</span><span class="p">.</span><span class="n">targets2</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
</section>
<section id="run-group-analysis-on-time-generalization-results">
<h3><a class="toc-backref" href="#id99" role="doc-backlink">Run group analysis on time generalization results?</a><a class="headerlink" href="#run-group-analysis-on-time-generalization-results" title="Link to this heading">¶</a></h3>
<p>‘I have run, for each participant, <cite>cosmo_dim_generalization_measure</cite>. Now I would like to run group analysis to see if there are significant clusters. How can I do that?’</p>
<p>Consider the following example, using synthetic data:</p>
<blockquote>
<div><div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="c">%% generate synthetic data for this example</span>
<span class="n">sigma</span><span class="p">=</span><span class="mf">0.1</span><span class="p">;</span><span class="w"> </span><span class="c">% weak signal</span>
<span class="n">n</span><span class="p">=</span><span class="mi">20</span><span class="p">;</span><span class="w"> </span><span class="c">% number of participants</span>

<span class="n">dgm_ds_cell</span><span class="p">=</span><span class="nb">cell</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="k">for</span><span class="w"> </span><span class="n">k</span><span class="p">=</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span>
<span class="w">    </span><span class="n">sz</span><span class="p">=</span><span class="s">&#39;huge&#39;</span><span class="p">;</span>
<span class="w">    </span><span class="n">train_ds</span><span class="p">=</span><span class="n">cosmo_synthetic_dataset</span><span class="p">(</span><span class="s">&#39;type&#39;</span><span class="p">,</span><span class="s">&#39;timelock&#39;</span><span class="p">,</span><span class="s">&#39;size&#39;</span><span class="p">,</span><span class="n">sz</span><span class="p">,</span><span class="k">...</span>
<span class="w">                                           </span><span class="s">&#39;nchunks&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="s">&#39;seed&#39;</span><span class="p">,</span><span class="n">k</span><span class="o">*</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="k">...</span>
<span class="w">                                           </span><span class="s">&#39;sigma&#39;</span><span class="p">,</span><span class="n">sigma</span><span class="p">);</span>
<span class="w">    </span><span class="n">test_ds</span><span class="p">=</span><span class="n">cosmo_synthetic_dataset</span><span class="p">(</span><span class="s">&#39;type&#39;</span><span class="p">,</span><span class="s">&#39;timelock&#39;</span><span class="p">,</span><span class="s">&#39;size&#39;</span><span class="p">,</span><span class="n">sz</span><span class="p">,</span><span class="k">...</span>
<span class="w">                                           </span><span class="s">&#39;nchunks&#39;</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="s">&#39;seed&#39;</span><span class="p">,</span><span class="n">k</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="k">...</span>
<span class="w">                                           </span><span class="s">&#39;sigma&#39;</span><span class="p">,</span><span class="n">sigma</span><span class="p">);</span>


<span class="w">    </span><span class="n">train_ds_time</span><span class="p">=</span><span class="n">cosmo_dim_transpose</span><span class="p">(</span><span class="n">train_ds</span><span class="p">,</span><span class="s">&#39;time&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="n">test_ds_time</span><span class="p">=</span><span class="n">cosmo_dim_transpose</span><span class="p">(</span><span class="n">test_ds</span><span class="p">,</span><span class="s">&#39;time&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>

<span class="w">    </span><span class="c">% set chunks</span>
<span class="w">    </span><span class="n">train_ds_time</span><span class="p">.</span><span class="n">sa</span><span class="p">.</span><span class="n">chunks</span><span class="p">(:)=</span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="n">test_ds_time</span><span class="p">.</span><span class="n">sa</span><span class="p">.</span><span class="n">chunks</span><span class="p">(:)=</span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="c">%</span>
<span class="w">    </span><span class="c">% construct the dataset</span>
<span class="w">    </span><span class="n">ds_time</span><span class="p">=</span><span class="n">cosmo_stack</span><span class="p">({</span><span class="n">train_ds_time</span><span class="p">,</span><span class="w"> </span><span class="n">test_ds_time</span><span class="p">});</span>

<span class="w">    </span><span class="c">% only to make this example run fast, most channels are eliminated</span>
<span class="w">    </span><span class="c">% (there is no other reason to do this step)</span>
<span class="w">    </span><span class="n">ds_time</span><span class="p">=</span><span class="n">cosmo_slice</span><span class="p">(</span><span class="n">ds_time</span><span class="p">,</span><span class="n">ds_time</span><span class="p">.</span><span class="n">fa</span><span class="p">.</span><span class="n">chan</span><span class="o">&lt;=</span><span class="mi">20</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
<span class="w">    </span><span class="n">ds_time</span><span class="p">=</span><span class="n">cosmo_dim_prune</span><span class="p">(</span><span class="n">ds_time</span><span class="p">);</span>

<span class="w">    </span><span class="c">% set measure and its arguments</span>
<span class="w">    </span><span class="n">measure_args</span><span class="p">=</span><span class="nb">struct</span><span class="p">();</span>
<span class="w">    </span><span class="c">%</span>
<span class="w">    </span><span class="c">% use correlation measure</span>
<span class="w">    </span><span class="n">measure_args</span><span class="p">.</span><span class="n">measure</span><span class="p">=@</span><span class="n">cosmo_correlation_measure</span><span class="p">;</span>
<span class="w">    </span><span class="c">% dimension of interest is &#39;time&#39;</span>
<span class="w">    </span><span class="n">measure_args</span><span class="p">.</span><span class="n">dimension</span><span class="p">=</span><span class="s">&#39;time&#39;</span><span class="p">;</span>
<span class="w">    </span><span class="c">%</span>
<span class="w">    </span><span class="c">% run time-by-time generalization analysis</span>
<span class="w">    </span><span class="n">dgm_ds</span><span class="p">=</span><span class="n">cosmo_dim_generalization_measure</span><span class="p">(</span><span class="n">ds_time</span><span class="p">,</span><span class="n">measure_args</span><span class="p">,</span><span class="k">...</span>
<span class="w">                                            </span><span class="s">&#39;progress&#39;</span><span class="p">,</span><span class="nb">false</span><span class="p">);</span>
<span class="w">    </span><span class="c">% put result from first-level analysis for k-th participants in ds_cell</span>
<span class="w">    </span><span class="n">dgm_ds_cell</span><span class="p">{</span><span class="n">k</span><span class="p">}=</span><span class="n">dgm_ds</span><span class="p">;</span>
<span class="k">end</span>

<span class="c">%%</span>
<span class="c">% We have now the results from cosmo_dim_generalization_measure in</span>
<span class="c">% dgm_ds_cell. The next step is to change the dimensions so that</span>
<span class="c">% the dimensions become feature dimensions. (this makes it possible</span>
<span class="c">% to cluster the data.)</span>
<span class="n">group_cell</span><span class="p">=</span><span class="nb">cell</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="k">for</span><span class="w"> </span><span class="n">k</span><span class="p">=</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span>
<span class="w">    </span><span class="n">dgm_ds</span><span class="p">=</span><span class="n">dgm_ds_cell</span><span class="p">{</span><span class="n">k</span><span class="p">};</span>

<span class="w">    </span><span class="c">% make train_time and test_time a feature dimension</span>
<span class="w">    </span><span class="n">ds</span><span class="p">=</span><span class="n">cosmo_dim_transpose</span><span class="p">(</span><span class="n">dgm_ds</span><span class="p">,{</span><span class="s">&#39;train_time&#39;</span><span class="p">,</span><span class="w"> </span><span class="s">&#39;test_time&#39;</span><span class="w"> </span><span class="p">},</span><span class="mi">2</span><span class="p">);</span>

<span class="w">    </span><span class="c">% for one-sample t-test</span>
<span class="w">    </span><span class="n">ds</span><span class="p">.</span><span class="n">sa</span><span class="p">.</span><span class="n">targets</span><span class="p">=</span><span class="mi">1</span><span class="p">;</span>

<span class="w">    </span><span class="c">% each participant is independent</span>
<span class="w">    </span><span class="n">ds</span><span class="p">.</span><span class="n">sa</span><span class="p">.</span><span class="n">chunks</span><span class="p">=</span><span class="n">k</span><span class="p">;</span>

<span class="w">    </span><span class="n">group_cell</span><span class="p">{</span><span class="n">k</span><span class="p">}=</span><span class="n">ds</span><span class="p">;</span>
<span class="k">end</span>

<span class="n">group_ds</span><span class="p">=</span><span class="n">cosmo_stack</span><span class="p">(</span><span class="n">group_cell</span><span class="p">);</span>

<span class="c">%%</span>
<span class="c">% We have now the results from participants in the required data structure,</span>
<span class="c">% where in group_ds.samples: each row represents a participant,</span>
<span class="c">% each column represents a combination of train and test time.</span>

<span class="c">% define the clustering neighborhood. By default, features next to each</span>
<span class="c">% other in time (train time or test time) are considered neighbors.</span>
<span class="n">nbrhood</span><span class="p">=</span><span class="n">cosmo_cluster_neighborhood</span><span class="p">(</span><span class="n">group_ds</span><span class="p">);</span>

<span class="c">% define clusterintg options.</span>
<span class="n">opt</span><span class="p">=</span><span class="nb">struct</span><span class="p">();</span>
<span class="n">opt</span><span class="p">.</span><span class="n">cluster_stat</span><span class="p">=</span><span class="s">&#39;tfce&#39;</span><span class="p">;</span><span class="w">  </span><span class="c">% Threshold-Free Cluster Enhancement;</span>
<span class="w">                          </span><span class="c">% this is a (very reasonable) default</span>

<span class="n">opt</span><span class="p">.</span><span class="n">niter</span><span class="p">=</span><span class="mi">500</span><span class="p">;</span><span class="w">          </span><span class="c">% this is way too small except for testing;</span>
<span class="w">                        </span><span class="c">% should usually be &gt;=1000;</span>
<span class="w">                        </span><span class="c">% better is &gt;=10,000</span>

<span class="n">opt</span><span class="p">.</span><span class="n">h0_mean</span><span class="p">=</span><span class="mi">0</span><span class="p">;</span><span class="w">          </span><span class="c">% test against mean of zero. For accuracies from</span>
<span class="w">                        </span><span class="c">% M balanced classes, use 1/M. For split-half</span>
<span class="w">                        </span><span class="c">% correlations, use 0.</span>


<span class="c">% run multiple comparison correction</span>
<span class="n">ds_result</span><span class="p">=</span><span class="n">cosmo_montecarlo_cluster_stat</span><span class="p">(</span><span class="n">group_ds</span><span class="p">,</span><span class="w"> </span><span class="n">nbrhood</span><span class="p">,</span><span class="w"> </span><span class="n">opt</span><span class="p">);</span>

<span class="c">%%</span>
<span class="c">% for easier unflattenening, the time dimensions are moved back</span>
<span class="c">% from feature to sample dimensions</span>
<span class="n">ds_result_time</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">cosmo_dim_transpose</span><span class="p">(</span><span class="n">ds_result</span><span class="p">,</span><span class="k">...</span>
<span class="w">                                    </span><span class="p">{</span><span class="w"> </span><span class="s">&#39;train_time&#39;</span><span class="p">,</span><span class="w"> </span><span class="s">&#39;test_time&#39;</span><span class="w"> </span><span class="p">});</span>

<span class="c">% flatten into a 2D array</span>
<span class="p">[</span><span class="n">arr</span><span class="p">,</span><span class="n">dim_labels</span><span class="p">,</span><span class="n">dim_values</span><span class="p">]=</span><span class="n">cosmo_unflatten</span><span class="p">(</span><span class="n">ds_result_time</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>

<span class="c">% plot the results</span>
<span class="nb">imagesc</span><span class="p">(</span><span class="n">arr</span><span class="p">);</span>
<span class="nb">colorbar</span><span class="p">();</span>

<span class="n">ytick</span><span class="p">=</span><span class="mi">1</span><span class="p">:</span><span class="nb">numel</span><span class="p">(</span><span class="n">dim_values</span><span class="p">{</span><span class="mi">1</span><span class="p">});</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="nb">strrep</span><span class="p">(</span><span class="n">dim_labels</span><span class="p">{</span><span class="mi">1</span><span class="p">},</span><span class="s">&#39;_&#39;</span><span class="p">,</span><span class="s">&#39; &#39;</span><span class="p">));</span>
<span class="nb">set</span><span class="p">(</span><span class="nb">gca</span><span class="p">,</span><span class="s">&#39;Ytick&#39;</span><span class="p">,</span><span class="n">ytick</span><span class="p">,</span><span class="s">&#39;YTickLabel&#39;</span><span class="p">,</span><span class="n">dim_values</span><span class="p">{</span><span class="mi">1</span><span class="p">}(</span><span class="n">ytick</span><span class="p">));</span>

<span class="n">xtick</span><span class="p">=</span><span class="mi">1</span><span class="p">:</span><span class="nb">numel</span><span class="p">(</span><span class="n">dim_values</span><span class="p">{</span><span class="mi">2</span><span class="p">});</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="nb">strrep</span><span class="p">(</span><span class="n">dim_labels</span><span class="p">{</span><span class="mi">2</span><span class="p">},</span><span class="s">&#39;_&#39;</span><span class="p">,</span><span class="s">&#39; &#39;</span><span class="p">));</span>
<span class="nb">set</span><span class="p">(</span><span class="nb">gca</span><span class="p">,</span><span class="s">&#39;Xtick&#39;</span><span class="p">,</span><span class="n">xtick</span><span class="p">,</span><span class="s">&#39;XTickLabel&#39;</span><span class="p">,</span><span class="n">dim_values</span><span class="p">{</span><span class="mi">2</span><span class="p">}(</span><span class="n">xtick</span><span class="p">));</span>
</pre></div>
</div>
</div></blockquote>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/cosmomvpa_logo.png" alt="Logo of CoSMo Multivariate Pattern Analysis toolbox"/>
            </a></p>
  <div>
    <h3><a href="index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">Frequently Asked/Anticipated Questions</a><ul>
<li><a class="reference internal" href="#general">General</a><ul>
<li><a class="reference internal" href="#how-should-i-cite-cosmomvpa">How should I cite CoSMoMVPA?</a></li>
<li><a class="reference internal" href="#what-is-the-history-of-cosmomvpa">What is the history of CoSMoMVPA?</a></li>
<li><a class="reference internal" href="#what-are-the-main-features">What are the main features?</a></li>
<li><a class="reference internal" href="#what-does-cosmomvpa-not-provide">What does CoSMoMVPA <em>not</em> provide?</a></li>
<li><a class="reference internal" href="#does-it-integrate-with-pymvpa">Does it integrate with PyMVPA?</a></li>
<li><a class="reference internal" href="#does-it-run-on-gnu-octave">Does it run on GNU Octave?</a></li>
<li><a class="reference internal" href="#how-fast-does-it-run">How fast does it run?</a></li>
<li><a class="reference internal" href="#what-should-i-use-as-input-for-mvpa">What should I use as input for MVPA?</a></li>
<li><a class="reference internal" href="#who-are-the-developers-of-cosmomvpa">Who are the developers of CoSMoMVPA?</a></li>
<li><a class="reference internal" href="#which-classifiers-are-available">Which classifiers are available?</a></li>
<li><a class="reference internal" href="#which-platforms-does-it-support">Which platforms does it support?</a></li>
<li><a class="reference internal" href="#what-future-features-can-be-expected">What future features can be expected?</a></li>
<li><a class="reference internal" href="#how-can-i-contact-the-developers-directly">How can I contact the developers directly?</a></li>
<li><a class="reference internal" href="#is-there-a-mailinglist">Is there a mailinglist?</a></li>
<li><a class="reference internal" href="#why-do-you-encourage-balanced-partitions">Why do you encourage balanced partitions?</a></li>
<li><a class="reference internal" href="#does-the-lda-linear-discriminant-analysis-classifier-use-shrinkage-normalization">Does the LDA (linear discriminant analysis) classifier use shrinkage / normalization?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#how-do-i">How do I …</a><ul>
<li><a class="reference internal" href="#find-the-correspondence-between-voxel-indices-in-afni-and-feature-indices-in-cosmomvpa">Find the correspondence between voxel indices in AFNI and feature indices in CoSMoMVPA</a></li>
<li><a class="reference internal" href="#get-ecog-data-in-a-cosmomvpa-struct">Get ECoG data in a CoSMoMVPA struct</a></li>
<li><a class="reference internal" href="#get-temporal-data-in-a-cosmomvpa-struct">Get temporal data in a CoSMoMVPA struct</a></li>
<li><a class="reference internal" href="#run-group-analysis">Run group analysis</a></li>
<li><a class="reference internal" href="#make-an-intersection-mask-across-participants">Make an intersection mask across participants</a></li>
<li><a class="reference internal" href="#compute-for-a-group-of-participants-who-were-scanned-with-mri-the-overlap-of-their-masks">Compute for a group of participants who were scanned with MRI the overlap of their masks</a></li>
<li><a class="reference internal" href="#run-group-analysis-on-time-by-time-generalization-measures">Run group analysis on time-by-time generalization measures</a></li>
<li><a class="reference internal" href="#use-libsvm">Use LIBSVM</a></li>
<li><a class="reference internal" href="#use-surface-based-mapping-with-a-low-resolution-output-surface">Use surface-based mapping with a low-resolution output surface</a></li>
<li><a class="reference internal" href="#correct-for-multiple-comparisons">Correct for multiple comparisons</a></li>
<li><a class="reference internal" href="#do-cross-modal-decoding-across-three-modalities">Do cross-modal decoding across three modalities</a></li>
<li><a class="reference internal" href="#compute-classification-accuracies-manually">Compute classification accuracies manually</a></li>
<li><a class="reference internal" href="#make-a-merged-hemisphere-from-a-left-and-right-hemisphere">Make a merged hemisphere from a left and right hemisphere</a></li>
<li><a class="reference internal" href="#merge-surface-data-from-two-hemispheres">Merge surface data from two hemispheres</a></li>
<li><a class="reference internal" href="#visualize-and-store-multiple-fmri-volumes">Visualize and store multiple fMRI volumes</a></li>
<li><a class="reference internal" href="#average-along-features-in-a-neighborhood">Average along features in a neighborhood</a></li>
<li><a class="reference internal" href="#select-a-time-interval-in-an-meeg-dataset">Select a time interval in an MEEG dataset</a></li>
<li><a class="reference internal" href="#select-a-particular-channel-type-in-an-meeg-dataset">Select a particular channel type in an MEEG dataset</a></li>
<li><a class="reference internal" href="#use-only-a-subset-of-channels-for-my-analysis">Use only a subset of channels for my analysis?</a></li>
<li><a class="reference internal" href="#should-i-fisher-transform-correlation-values">Should I Fisher-transform correlation values?</a></li>
<li><a class="reference internal" href="#average-samples-in-a-deterministic-manner">Average samples in a deterministic manner?</a></li>
<li><a class="reference internal" href="#select-only-a-subset-of-features-in-a-neighborhood">Select only a subset of features in a neighborhood?</a></li>
<li><a class="reference internal" href="#use-multiple-comparison-correction-for-a-time-course">Use multiple-comparison correction for a time course?</a></li>
<li><a class="reference internal" href="#classify-different-groups-of-participants-such-as-patients-versus-controls">Classify different groups of participants (such as patients versus controls)?</a></li>
<li><a class="reference internal" href="#when-running-an-meeg-searchlight-have-the-same-channels-in-the-output-dataset-as-in-the-input-dataset">When running an MEEG searchlight, have the same channels in the output dataset as in the input dataset?</a></li>
<li><a class="reference internal" href="#save-meeg-data-when-i-get-the-error-value-for-fdim-channel-label-is-not-supported">Save MEEG data when I get the error “value for fdim channel label is not supported”?</a></li>
<li><a class="reference internal" href="#run-a-2-x-2-within-subject-anova">Run a 2 x 2 within-subject ANOVA?</a></li>
<li><a class="reference internal" href="#use-a-fieldtrip-source-dataset-that-uses-a-fake-channel-structure">Use a FieldTrip source dataset that uses a ‘fake’ channel structure</a></li>
<li><a class="reference internal" href="#run-cosmo-montecarlo-cluster-stat-on-a-cluster-with-multiple-nodes">Run <cite>cosmo_montecarlo_cluster_stat</cite> on a cluster with multiple nodes</a></li>
<li><a class="reference internal" href="#why-should-i-consider-re-meaning-when-doing-representational-similarity-analysis-rsa">Why should I consider re-meaning when doing representational similarity analysis (RSA)?</a></li>
<li><a class="reference internal" href="#import-brainstorm-data">Import BrainStorm data</a></li>
<li><a class="reference internal" href="#compute-the-correlation-between-two-dissimilarity-matrices">Compute the correlation between two dissimilarity matrices</a></li>
<li><a class="reference internal" href="#use-the-generalization-measure-with-different-durations-for-training-and-test-set">Use the generalization measure with different durations for training and test set?</a></li>
<li><a class="reference internal" href="#get-the-classifier-weights-after-training-a-classifier">Get the classifier weights after training a classifier?</a></li>
<li><a class="reference internal" href="#get-coordinates-of-voxels-in-a-cosmomvpa-fmri-dataset">Get coordinates of voxels in a CoSMoMVPA fMRI dataset?</a></li>
<li><a class="reference internal" href="#compute-representational-similarity-across-chunks">Compute representational similarity across chunks?</a></li>
<li><a class="reference internal" href="#run-group-analysis-on-time-generalization-results">Run group analysis on time generalization results?</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="matlab/demo_surface_tfce.html"
                          title="previous chapter">demo surface tfce</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="contact.html"
                          title="next chapter">Contact information</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/faq.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="contact.html" title="Contact information"
             >next</a> |</li>
        <li class="right" >
          <a href="matlab/demo_surface_tfce.html" title="demo surface tfce"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">CoSMoMVPA</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="documentation.html" >Documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Frequently Asked/Anticipated Questions</a></li> 
      </ul>
    </div>
      <div class="footer">
       <span class="creativecommons">
          <a href="http://opensource.org/licenses/MIT" >
          <img src="_static/mit-license_logo.png"
               border="0" alt="Creative Commons License"/>
         </a> 
         
        <a href="copyright.html">Copyright 2013-2021 Nikolaas N. Oosterhof, Andrew C. Connolly, CoSMoMVPA contributors</a>.
        CoSMoMVPA is licensed under an <a href="http://opensource.org/licenses/MIT">Expat (MIT) License</a>.
       </span>
      </div>
  </body>
</html>